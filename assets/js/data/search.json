[ { "title": "[오늘의 배움] DNS와 DHCP", "url": "/posts/DNS-DHCP/", "categories": "오늘의배움, 네트워크", "tags": "오늘의배움, 네트워크", "date": "2023-01-26 00:00:00 +0900", "snippet": " DNSDomain Name System의 약자로 사람들이 읽기 쉬운 영문/한글 주소를 IP주소로 변환해준다.DNS를 운영하는 서버는 네임서버(Name Server)라고 한다. DHCPDynamic Host Configuration Protocol의 약자로 호스트의 IP주소 외에도 다양한 네트워크 정보를 클라이언트에게 자동적으로 할당해주는 프로토콜이다.다수의 컴퓨터에 IP를 자동으로 할당되기 때문에 IP 충돌을 막을 수 있지만 DHCP서버가 다운되면 IP 할당이 이루어지지 않는다" }, { "title": "[오늘의 배움] Context Switching", "url": "/posts/Context-switching/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2023-01-25 00:00:00 +0900", "snippet": " Context Switching하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 먼저 사용하고 있던 프로세스의 PCB정보를Register에 보관(저장)하고 다른 프로세스를 처리하는 과정을 말한다.프로세스가 끝나면 Register에 저장한 먼저 사용하고 있던 프로세스의 PCB정보를 읽어 이어서 작업한다." }, { "title": "[오늘의 배움] TCP의 제어", "url": "/posts/TCP/", "categories": "오늘의배움, 네트워크", "tags": "오늘의배움, 네트워크", "date": "2023-01-17 00:00:00 +0900", "snippet": " TCP의 제어전송 프로토콜인 TCP에는 대표적인 3가지 제어가 있다. 흐름제어 송신측과 수신측 사이에 데이터 처리 속도 차이를 제어하기 위한 기법 송신측은 수신측의 데이터 처리속도를 파악하고 어느정도의 데이터 양을 보낼지 결정 송신측의 속도가 빠를 경우 발생, 수신측에서 오버플로우를 방지 Stop and Wait / Sliding Window 혼잡제어 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법 오버플로우 또는 데이터 손실 방지 송신측에서 보내는 데이터의 전송 속도를 제어 오류제어 오류 검출과 재전송을 담당 Stop and Wait ARQ / Go-Back-n ARQ" }, { "title": "[오늘의 배움] 컴파일러와 인터프리터의 차이", "url": "/posts/Compiler-Interpreter/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2023-01-16 00:00:00 +0900", "snippet": " 컴파일러 한 번에 파일을 컴퓨터 언어로 번역함 처음 실행에는 오래 걸리지만 번역하고 나면 파일로 만들어져 빠름 전체 코드를 스캔 후 번역하기 때문에 실행 전 오류를 알 수 있음 코드를 수정하면 다시 컴파일 해야함컴파일러 언어 : C / C++ / JAVA 인터프리터 실행 시 한 번에 한 줄씩 번역함 한 줄씩 실행하기 때문에 컴파일러보다 느림 실행 후 오류를 알 수 있음인터프리터 언어 : JavaScript / Python / Ruby" }, { "title": "[오늘의 배움] TCP와 UDP", "url": "/posts/TCPUDP/", "categories": "오늘의배움, 네트워크", "tags": "오늘의배움, 네트워크", "date": "2023-01-12 00:00:00 +0900", "snippet": " TCP(Transmission Control Protocol) 란?전송계층에 연결지향형 프로토콜로 두 개의 호스트가 데이터를 주고 받을 때 에러 없이, 순서 보장과 신뢰성있는 전달을 해주는 프로토콜이다. UDP(User Datagram Protocol)UDP는 전송계층에 비연결형 프로토콜로 두 개의 호스트가 데이터를 주고 받을 때 순서를 보장하지 않고 일방적으로 데이터를 보내는 프로토콜이다.그래서 TCP보다는 속도는 빠르지만 신뢰성을 보장하지 않으므로 데이터 손실이 발생할 수 있다는 특징이 있다." }, { "title": "[오늘의 배움] 운영체제", "url": "/posts/OS/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2023-01-11 00:00:00 +0900", "snippet": " 운영체제란?운영체제는 사용자가 하드웨어와 시스템 리소스를 제어를 다룰 수 있도록 도와주는 소프트웨어이다.즉 사용자가 컴퓨터를 쉽게 다룰 수 있게 도와주는 것이다. 종류운영체제의 종류에는 Windows, Unix, Linux, Mac OS 등이 있다. 목적 사용자가 하드웨어를 관리하는 것이다. 사용자에게 프로그램을 쉽고 효율적으로 실행할 수 있는 환경을 제공한다. 하드웨어 및 소프트웨어 자원을 여러 사용자 간에 효율적 할당, 관리, 보호 하는 것이다. 운영체제는 제어프로그램으로써 프로그램의 오류나 잘못된 자원 사용을 감시하는 것이다. 입출력 장치 등의 자원에 대한 연산과 제어를 관리한다.출처 : 운영체제 위키백과" }, { "title": "[오늘의 배움] 자동 재전송 방식 ARQ", "url": "/posts/ARQ/", "categories": "오늘의배움, 네트워크", "tags": "오늘의배움, 네트워크", "date": "2023-01-10 00:00:00 +0900", "snippet": " ARQ 란?Auto Repeat Request의 약자로 자동 재전송 요구라고 한다.데이터가 손상되었을 경우 재전송을 통해 오류를 복구하는 방식이다.ARQ에는 종류는 아래와 같다. 정지 대기 방식 (Stop and Wait) 한 번에 하나씩 데이터를 전송하고 ACK 응답을 기다린 후 다음 데이터를 전송한다. NAK 응답을 받으면 재전송한다. 가장 단순하지만 비효율적이다. 연속적 ARQ (Go Back n ARQ 또는 Continuous ARQ) 한 번에 여러개의 데이터를 보낸 후 하나의 확인 응답을 받고 다음 데이터를 전송한다. NAK을 받을 때까지 데이터를 전송한다. 만약 NAK 발생 시, NAK 발생 한 이후 데이터를 재전송한다. 선택적 재전송 (Selective Repeat ARQ) 연속적 ARQ 방식과 비슷하지만 NAK 응답 이후 데이터가 아니라 NAK 응답한 데이터만 재전송한다. 적응적 방식(Adaptive ARQ) 적응적으로 ARQ 횟수를 줄여 전송 효율을 높이는 방식" }, { "title": "[오늘의 배움] RAM과 ROM의 차이", "url": "/posts/RAM-ROM/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2023-01-09 00:00:00 +0900", "snippet": " RAM 이란?Random Access Memory의 약자로 메모리가 휘발성이라는 특징이 있다.즉, 전원이 차단되면 데이터가 사라진다. ROM 이란?Read Only Memory의 약자로 RAM과 다르게 비휘발성 메모리이다.즉, 전원이 차단되어도 데이터가 사라지지 않는다." }, { "title": "[오늘의 배움] 패킷교환방식과 회선교환방식", "url": "/posts/circuit-packet/", "categories": "오늘의배움, 네트워크", "tags": "오늘의배움, 네트워크", "date": "2023-01-01 00:00:00 +0900", "snippet": " 회선교환 방식이란?데이터를 전송하기 전에 연결 경로를 미리 설정하는 방식이다.경로를 독점적(전용선)으로 사용하기 때문에 사용하는 동안에는 다른 곳에서는 사용할 수 없다.고정적인 대역폭을 사용한다. 패킷교환 방식이란?보내려고 하는 데이터를 패킷단위로 나눠서 보내는 방식이다.패킷은 헤더, 데이터, 트레일러로 나눠져 있다.회선교환 방식과 다르게 전용선이 없으며 라우터가 패킷을 최적경로를 설정한다.목적지까지 여러가지 경로가 있는데 매번 같은 경로로 가지 않고 패킷마다 다른 경로로 갈 수 있다.그래서 출발할 때는 순서대로 출발하지만 도착할 때는 순서대로 도착하지는 않는다." }, { "title": "[오늘의 배움] 서브넷팅이란", "url": "/posts/subnetting/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2022-12-31 00:00:00 +0900", "snippet": " 서브넷팅이란효율적인 IP 사용을 위해(아이피 주소를 낭비하지 않기 위해) 네트워크를 분리하는 과정을 말한다." }, { "title": "[오늘의 배움] 우선순위 큐", "url": "/posts/Priority-queue/", "categories": "오늘의배움, 자료구조", "tags": "오늘의배움, 자료구조", "date": "2022-12-29 00:00:00 +0900", "snippet": " 우선순위 큐란?일반적으로 큐는 선입선출(FIFO) 개념으로 먼저 들어온 데이터가 먼저 나가는 형식의 자료구조이다.우선순위 큐는 각각의 원소들이 우선순위를 갖기 때문에 들어간 순서와 상관없이 우선순위가 높은 원소들 먼저 처리가 된다.우선순위 큐는 힙을 기반으로 구현된다.힙은 완전 이진트리 기반의 자료구조이다.최대힙 - 부모의 원소(노드)가 자식의 원소(노드)보다 큰 것을 의미최소힙 - 부모의 원소(노드)가 자식의 원소(노드)보다 작은 것을 의미 동작방식 삽입원소가 삽입이 될 때 완전 이진트리를 유지하면서 순차적으로 삽입이 된다.삽입 이후 노드를 비교해가며 루트 노드로 거슬러 올라가면서 최대 힙을 만족하도록 구성한다 삭제삭제될 때는 루트 노드를 삭제하고 마지막 노드를 루트 노드 자리로 옮긴다.이후 최대 힙을 만족하도록 구성한다." }, { "title": "[오늘의 배움] 가상메모리", "url": "/posts/virtualMemory/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2022-12-28 00:00:00 +0900", "snippet": " 가상 메모리에 대해 알아보기 전 알아야할 개념 ! 메모리는 내부 기억장치인 주 기억장치와 외부 기억장치인 보조 기억장치로 나눠진다.주기억장치 : RAM, CPU의 레지스터, 캐시보조 기억장치 : HDD, SSD 가상 메모리란?가상 메모리는 사용자에게 메모리를 매우 큰 메모리로 보이게 만드는 것이다.프로그램을 실행 시킬 때 현재 메모리로는 실행 시키지 못한다면, 프로그램을 실행 시킬 수 있는 최소한의 메모리를 주기억장치로 사용하고 나머지는 보조기억장치를 사용해 프로그램을 실행 시킨다.이 처럼 실제 메모리를 적지만 보조기억장치의 도움을 받아 실행 시키므로 사용자에게 메모리를 더 커보이게 만들 수 있다." }, { "title": "[오늘의 배움] 세션과 쿠키", "url": "/posts/Session-Cookie/", "categories": "오늘의배움, http", "tags": "오늘의배움, http", "date": "2022-12-27 00:00:00 +0900", "snippet": " 쿠키란?클라이언트(브라우저)에 저장되는 데이터이다.쿠키에는 유효기간을 설정할 수가 있는데 이것은 브라우저를 꺼도 유효기간이 남아 있으면 쿠키를 적용할 수 있다.저장된 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 자동으로 설정해준다.어떠한 웹사이트에 로그인하고 다시 요청해도 로그인한 상태로 남아 있는 것이 쿠키가 설정되어 있어서라고 할 수 있다. 세션이란?세션은 쿠키를 기반으로 하고 있지만 쿠키는 데이터를 클라이언트에 저장하지만 세션은 서버에 저장한다.세션은 브라우저를 닫기 전 까지만 유효하다. 차이점 저장되는 위치가 다르다(쿠키는 클라이언트 세션은 서버) 쿠키는 request 정보가 보이기 때문에 보안에 취약하다. 세션은 서버에서 처리를 하기 때문에 속도가 쿠키보다 느리다" }, { "title": "[오늘의 배움] 로깅을 이용한 데이터베이스의 회복(Recovery)", "url": "/posts/DataBaseRecovery/", "categories": "오늘의배움, 데이터베이스", "tags": "오늘의배움, 데이터베이스", "date": "2022-12-26 00:00:00 +0900", "snippet": " 회복이란?트랜젝션들을 수행하는 도중에 장애로 인해 손상된 데이터베이스를 정상적인 상태로 복구시키는 작업을 말한다. 로그 기반 회복회복 방법들 중 로그를 이용한 회복 기법이 두 가지가 있다. 지연 갱신 회복 기법 트랜젝션이 부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고 데이터베이스에는 반영하지 않는 기법(commit 전까지 반영하지 않음) 중간에 장애가 발생하더라도 데이터베이스에는 commit전 까지는 반영되지 않았기 때문에 해당 로그 파일내용만 버리면 된다. 즉시 갱신 회복 기법 트랜젝션 도중 데이터를 변경하면 변경 정보를 로그파일에 저장하고 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법 변경된 데이터에 대해서는 redo 수행, 변경되지 않은 데이터들에 대해서는 undo를 수행해야 한다.❗❗❗💡 Undo: 트랜잭션 로그를 이용하여 오류와 관련된 모든 변경을 취소하여 복구 수행💡 Redo: 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 재실행하여 복구 수행" }, { "title": "[오늘의 배움] AVL 트리", "url": "/posts/AVL-Tree/", "categories": "오늘의배움, 자료구조", "tags": "오늘의배움, 자료구조", "date": "2022-12-23 00:00:00 +0900", "snippet": " AVL 트리란?AVL은 자가 균형 이진 탐색트리이다.만약 한쪽으로 쏠린 이진트리가 되면 자료를 찾을 때 루트부터 끝까지 찾아야할 수도 있다.이 단점을 보완한 것이 AVL 트리 이다.AVL트리는 말 그대로 스스로 균형을 잡는 트리인데 이 트리의 특징은서브트리의 높이들은 항상 1만큼만 차이가 난다.만약 차이가 1보다 커지면 1만큼만 차이나도록 스스로 균형을 잡는다.균형을 잡을 때 방법은 회전을 하는 것인데 LL, RR, LR, RL로 4가지가 있다.참조 💡위키백과 AVL트리제로초님 블로그" }, { "title": "[오늘의 배움] 페이징(paging)과 세그멘테이션(segmentation)", "url": "/posts/pageSegmentation/", "categories": "오늘의배움, 운영체제", "tags": "오늘의배움, 운영체제", "date": "2022-12-22 00:00:00 +0900", "snippet": " 페이징(paging) 이란? 페이징이란 동일한 크기의 페이지 크기로 나누어 메모리에 적재하는 방식이다. 물리적 단위로 나눈다. 불연속적으로 할당한다. 홀의 크기가 균일하다. 내부 단편화가 발생할 수 있다. 세그멘테이션(segmentation) 이란? 크기가 동일하지 않은 세그먼트 단위로 나누어 메모리에 적재하는 방식이다. 논리적 단위(코드 영역, 데이터 영역 등 크기가 아닌 의미가 같은 단위)로 나눈다. 크기가 다르기 때문에 홀의 크기가 균일하지 않은 문제가 발생한다. 외부 단편화가 발생할 수 있다. 논리적 단위로 자르기 때문에 중요하지 않은 세그먼트, 중요한 세그먼트 내용으로 자를 수 있어서 보안과 공유 측면에서 페이징보다 좋다.❗❗❗💡 홀 이란? 할당할 수 있는 메모리의 공간을 말한다.💡 내부 단편화란? 메모리의 크기보다 프로세스의 크기가 더 작아 메모리의 낭비가 발생하는 현상💡 외부 단편화란? 메모리의 크기보다 프로세스의 크기가 더 커서 메모리에 할당하지 못하는 현상" }, { "title": "[오늘의 배움] 프록시 Proxy", "url": "/posts/proxy/", "categories": "오늘의배움, 네트워크", "tags": "오늘의배움, 네트워크", "date": "2022-12-21 00:00:00 +0900", "snippet": " 프록시란?대리라는 사전적 의미를 가지고 있다.보안상의 이유로 클라이언트와 서버가 직접 통신을 주고 받을 수 없는 상황에 그 사이에서 중계 역할을 해준다.단순히 대리로 통신을 해주는 역할을 하는 것 뿐만 아니라 프록시 서버에 요청된 내용들을 캐싱하고 있어다시 데이터를 받아와야하는 시간을 줄임으로써 전송 시간을 절약할 수 있는 이점이 있다.덕분에 네트워크 병목 현상을 방지하는 효과도 있다. 종류Forward Proxy클라이언트에서 요청을 할 때 프록시 서버를 거쳐서 요청하는 방법Reverse ProxyForward Proxy와 반대로 서버에서 클라이언트로 직접 데이터를 전달하지 않고 프록시 서버를 거쳐서 전달하는 방법" }, { "title": "[Error] React todo list 중 에러", "url": "/posts/React-bind/", "categories": "React", "tags": "React", "date": "2022-10-30 00:00:00 +0900", "snippet": "오늘은 React로 Todo List를 만드는 연습 중에 나온 에러를 정리하려고 한다.에러위와 같이 아이템 목록중에 삭제 버튼을 클릭하면 아이템이 삭제가 되어야 하는데 삭제는 안되고 아래와 같은 에러 메세지가 떴다.이유는 onClick에는 함수 포인터를 넘겨야하는데 함수를 호출하고 있어서 에러가 나오던 것이였다.해결방법첫 번째로는 bind 함수를 사용하는 방법이다.bind 함수는 새로운 함수를 반환해줘서 가능하다고 한다.두 번째 방법은 onClick으로 호출하는 함수를 따로 만드는 방법이다.이렇게 해주면 onClick에서 함수를 바로 호출하지 않기 때문에 에러가 나지 않는다." }, { "title": "[PUPPETEER] PUPPETEER에 대한 정리 1", "url": "/posts/puppeteer1/", "categories": "PUPPETEER, Node.js", "tags": "PUPPETEER, Node.js", "date": "2022-09-17 00:00:00 +0900", "snippet": "오늘은 최근에 사용하게 된 PUPPETEER에 대한 정리를 해보려고 한다.PUPPETEER는 구글에서 만들었다고 한다. 구글갓PUPPETEER는 웹 크롤링? 스크랩?을 할 수 있도록 도와주는 라이브러리이다.최근 사용해 봤을 때 할 수 있는 동작들이 굉장히 많았다.마우스 왼쪽 오른쪽 클릭, 페이지 이동, 자바스크립트 함수 실행 등 거의 사람이 페이지에 들어가서할 수 있는 동작들을 다 한다고 생각하면 될 것 같다.오늘 정리하는 것도 내가 사용 해봤던 것들 위주로 정리를 해볼 예정이다. PUPPETEER? PUPPETEER-CORE?PUPPETEER를 사용하기 전에 두 가지 버전이 있는데 PUPPETEER와 PUPPETEER-CORE가 있다.이 두 가지 버전은 비슷하지만 차이점은 설치 시 PUPPETEER는 *Chromium을 포함해 설치가 되고,PUPPETEER-CORE는 Chromium을 포함하지 않고 설치가 된다.💡 Chromium 이란?이거 말고는 PUPPETEER_* 환경 변수들을 사용여부 차이가 있다.PUPPETEER-CORE는 PUPPETEER의 경량화 버전이라고 보면 될 것 같다. 시작하기그럼 간단하게 기본적인 코드를 먼저 봐보자.const puppeteer = require(\"puppeteer\"); // === import puppeteer from 'puppeteer';const puppeteerInit = async () =&gt; { // headless : true 브라우저를 보이게 하지 않고 실행 // false 보이게 실행 const browser = await puppeteer.launch({ headless: false }); // browser.newPage()를 하게 되면 기본 탭한개에 새로운 탭 하나가 더 생성이 되어서 (browser.pages)[0]를 사용하게 됐다. const page = await browser.pages[0]; // 이동할 url에 protocol(http 또는 https)이 없으면 오류 발생 await page.goto(\"이동할 url\", { waitUntil: \"networkIdle2\" }); await browser.close();};일단 간단하게 페이지를 이동시키기만 해보았다.page.goto 코드 부분에 waitUntil은 페이지를 이동 후 다음 동작을 하기 전까지 기다리게 하는 속성이다.속성에는 4가지가 있는데 다음과 같다.networkIdle0 : 최소한 500ms 동안 네트워크 연결이 0개 이상 없을 때 탐색 완료로 간주(SPA 페이지에 사용)networkidle2 : 최소한 500ms 동안 두 개 이상의 네트워크 연결이 없을 때 탐색 완료로 간주domcontentload : HTML 문서가 다 로드 되고 DOM 트리가 완료 되었을 때load : load 이벤트가 완료 되었을 때domcontentload와 load는 개발자 도구에서 확인이 가능한데 이게 맞는 건지는 정확히 모르겠다..!그리고 goto 외에도 사용할 수 있는 제어 동작들이 click, type 등 여러가지가 있다.click과 type을 사용할 때는 내가 무엇을 클릭 해야할지를 알려줘야 하는데 알려주는방법으로는 selector를 사용하면 된다. jquery에서 내가 사용하고 싶은 선택자를 넣듯이 하면된다 !const puppeteer = require(\"puppeteer\");const puppeteerInit = async () =&gt; { const browser = await puppeteer.launch({ headless: false }); const page = await browser.pages[0]; // 페이지 이동후 waitUntil await page.goto(\"https://www.naver.com/\", { waitUntil: \"networkIdle2\" }); // 아래 사진과 같이 복사 후 붙여 넣기 await page.click(\"#account &gt; a\"); await browser.close();};위 사진처럼 selector를 복사 후 click 함수안에 넣어주면 끝이다.type도 마찬가지로 selector를 넣어준 후 두번째 인자에 내가 입력할 문자열을 넣어주면 된다.여기선 검색창에 타이핑을 하는 것으로 해보겠다.const puppeteer = require(\"puppeteer\");const puppeteerInit = async () =&gt; { const browser = await puppeteer.launch({ headless: false }); const page = await browser.pages[0]; await page.goto(\"https://www.naver.com/\", { waitUntil: \"networkIdle2\" }); // #query는 네이버 검색창의 css selector await page.type(\"#query\", \"안녕하세요\"); // 검색어 입력 후 엔터 await page.keyboard.press(\"Enter\"); await browser.close();};puppeteer는 이것만 가능 한 것이 아니라 활용하면 엄청난 크롤러를 만들 수 있을 것 같다.다음 정리 때는 $, $$, $eval, $$eval 이라는 키워드에 대해서 알아볼 예정이다 ~!" }, { "title": "[React] React router v6", "url": "/posts/routerV6/", "categories": "React", "tags": "React", "date": "2022-08-26 00:00:00 +0900", "snippet": "오늘은 router v5에서 router v6로 업데이트 하면서 바뀐 점이 있는데 공부하고 있는 프로젝트에 한해서 바뀐 점을 살펴보려고 한다. &lt;!-- v5 router --&gt;&lt;Switch&gt; &lt;Route path='/경로'&gt; &lt;컴포넌트 /&gt; &lt;/Route&gt; &lt;Route path='/경로'&gt; &lt;Redirect to='/경로'&gt; &lt;/Route&gt;&lt;/Switch&gt; 변경점 Switch 훅이 사라지고 Routes 훅이 생겼다. v6부터는 Route 훅을 Routes 훅으로 꼭 감싸주어야한다. Route에 path 속성으로 준 경로로 이동 시 보여줄 컴포넌트를 element 속성으로 넣으면 된다. 💡 jsx 코드 그대로 넣어주면 된다. Redirect 훅이 사라지고 대신에 Navigate 훅이 생겼다.위 변경점을 모두 적용하면 아래와 같다.&lt;!-- v6 router --&gt;&lt;Routes&gt; &lt;Route path=\"/경로\" element=\"{&lt;Navigate\" to=\"경로\" /&gt;} /&gt; &lt;Route path=\"/경로\" element=\"{&lt;컴포넌트\" /&gt;} /&gt;&lt;/Routes&gt;중첩 라우팅중첩 라우팅에서도 달라진 점이 있는데 먼저 코드를 보자.&lt;!-- v5 router --&gt;&lt;!-- App.js --&gt;&lt;Switch&gt; &lt;Route path=\"/경로1\"&gt; &lt;Other /&gt; &lt;/Route&gt;&lt;/Switch&gt;&lt;!-- Other.js --&gt;&lt;!-- 생략 --&gt;&lt;p&gt;Hi, Hello&lt;/p&gt;&lt;Route path=\"/경로1/경로2\"&gt; &lt;p&gt;CoJalDan&lt;/p&gt;&lt;/Route&gt;&lt;!-- 생략 --&gt;먼저 위에 변경점들을 다 적용시켜보자. &lt;!-- v6 router --&gt; &lt;!-- App.js --&gt;&lt;Routes&gt; &lt;Route path='/경로1' element={&lt;Other /&gt;} /&gt;&lt;/Routes&gt; &lt;!-- Other.js --&gt; &lt;!-- 생략 --&gt;&lt;p&gt;Hi, Hello&lt;/p&gt;&lt;Routes&gt; &lt;Route path='/경로2' element={&lt;p&gt;CoJalDan&lt;/p&gt;} /&gt;&lt;/Routes&gt;&lt;!-- 생략 --&gt; 변경점 중첩 라우팅을 할 때 상위 라우팅(컴포넌트)에서 보여줄 수 있다. 단 path가 같을 경우 path 경로에서 상위라우팅 경로를 빼야한다. 하위 라우팅(컴포넌트)에서 Outlet이라는 훅으로 위치를 지정할 수 있다. 위 목록들을 적용 시켜보자. &lt;!-- v6 router --&gt; &lt;!-- App.js --&gt;&lt;Routes&gt; &lt;Route path='/경로1/*' element={&lt;Other /&gt;} &gt; &lt;Route path='경로2' element={&lt;p&gt;CoJalDan&lt;/p&gt;} /&gt; &lt;/Route&gt;&lt;/Routes&gt; &lt;!-- Other.js --&gt; &lt;!-- 생략 --&gt;&lt;p&gt;Hi, Hello&lt;/p&gt;&lt;Outlet /&gt;&lt;!-- 생략 --&gt; 💡 위 경로에 * 는 v5에서 경로가 완전히 일치해야하는 경우에 썼던 exact와 같은 기능이다.틀린점 지적해주시면 감사하겠습니다 !" }, { "title": "[오늘의 배움] async await", "url": "/posts/async-await/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-08-21 00:00:00 +0900", "snippet": "오늘은 async await에 대해서 알아보자.먼저 들어가기 전에 Promise에 대해서 먼저 알고 보면 더 좋을 것 같다.async await이란 프로미스 기반으로 비동기 코드를 동기 코드처럼 보이게 도와주는 키워드이다.await 키워드는 반드시 async 함수 내부에서 사용해야 한다. 아니면 에러가 난다.async 함수는 프로미스를 반환한다.코드로 보면서 다시 이해해보자.예제코드 👇const timer = (time) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(time); }, time); });};timer(1000).then(console.log); // 1초 후 결과 -&gt; 1000만약 Promise로 1초 뒤 실행이 되는 코드를 짠다면 이런식으로 될 것이다.1초 후 실행되는 코드 다음 또 다시 1초 후 실행되는 코드를 짠다면 아래와 같을 것이다.const timer = (time) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(time); }, time); });};timer(1000) .then((time) =&gt; { console.log(time); return timer(time); }) .then(console.log);이렇게 계속 해서 찍는다면 또 코드가 복잡해진다..그래서 나온게 async await 인데 바로 바꿔 보자.예제코드 👇const timer = (time) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(time); }, time); });};let time = await timer(1000);console.log(time);time = await timer(1000);console.log(time);위 코드를 실행하면 어떻게 될까??위에서 말했듯이 async 없이 await 만 쓴다면 에러가 난다.그래서 await 을 async 함수 내부로 옮겨준다.const timer = (time) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(time); }, time); });};const run = async () =&gt; { let time = await timer(1000); console.log(time); time = await timer(1000); console.log(time);};run();코드만 본다면 일반적인 자바스크립트 처럼 동기 코드로 보인다.하지만 실제로 아래 코드처럼 run 함수 위아래로 console.log를 찍고 실행해보면 비동기적으로 동작을 한다.// ...생략console.log(\"start\");run();console.log(\"end\");/*resultstartendrun함수내용..*/이렇게 오늘은 async await에 대해서 공부해 봤는데 약간 이해가 되면서도 헷갈리는 부분이 조금 있는 거 같다..요즘 공부하기 귀찮아졌는데,, 화이팅 해보자 !!🔥" }, { "title": "[오늘의 배움] Promise", "url": "/posts/Promise/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-08-19 00:00:00 +0900", "snippet": "오늘은 Promise에 대해서 알아보자.자바스크립트는 비동기 처리를 위해 콜백함수를 사용하는데 이런 콜백함수는 가독성이 나쁘고 처리중 발생한 에러의 처리도 힘들고 한번에 여러개의 비동기 처리를 하기에는 한계가 있다.그래서 ES6부터는 비동기 처리의 방식 중 하나인 Promise라는 것을 도입했다.콜백함수로 처리하는 비동기 처리를 코드로 봐보자.const callback = (isOk, onSuccess, onError){ if(isOk){ onSuccess('success'); }else{ onError(new Error('fail')); }}callback(true, (value)=&gt;{console.log(value)}, (error) =&gt; {console.log(error)});예시 코드라서 간단해 보이지만 실무나 프로젝트에서 저런식으로 코드를 사용한다면 보기도 싫고 이해하기도 힘들것이다.이제 Promise를 한번 봐보자.const promise = new Promise((resolve, reject) =&gt; { if(/* 조건문 */){ resolve(\"success cojaldan\"); }else{ reject(new Error(\"error cojaldan\")); }});promise .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.log(error); })// 위 코드는 아래와 같이 쓸 수 있다.promise.then(console.log).catch(console.log);이렇게만 봐도 훨씬 가독성이 좋아진다.위 코드들은 예시코드라서 별로 안와닿을수도 있을 것 같다.또 then, catch 말고 finally라는 것도 있는데 이것은 선언한 함수가 성공이든 실패든지 실행하는 함수이다.promise .then((value) =&gt; { //여기 value의 값이 위 resolve의 매개변수 값이 됨 console.log(value); // result : success cojaldan }) .catch((error) =&gt; { // 여기 error의 값이 위 reject의 매개변수 값이 됨 console.log(error); // result : error cojaldan }) .finally(() =&gt; { // finally는 성공하든 실패하든 무조건 실행 console.log(\"finally\"); // result: finally });Promise 함수는 선언한 순간 호출하지 않아도 executor 함수가 실행이 됨여기서 executor 란 Promise를 선언할때 전달한 함수를 의미const promise = new Promise((resolve, reject) =&gt; { console.log('cojaldan'); // 호출하지 않아도 Promise가 선언되면 실행 if(/* 조건문 */){ resolve(\"success cojaldan\"); }else{ reject(new Error(\"error cojaldan\")); }});" }, { "title": "[React] redux-toolkit - createSlice, useDispatch, useSelector ", "url": "/posts/React-reduxtoolkit/", "categories": "React", "tags": "React", "date": "2022-08-09 00:00:00 +0900", "snippet": "createSlice, useDispatch, useSelector에 대한 간단한 정리createSlice : reducer와 같이 상황에 따라 상태를 변경할 수 있도록 하는 훅이다.const counterSlice = createSlice({ name: \"counter\", initialState: initialCounterState, reducers: { increment(state) { state.counter++; }, decrement(state) { state.counter--; }, increase(state, action) { state.counter = state.counter + action.payload; }, toggleCounter(state) { state.showCounter = !state.showCounter; }, },});원래는 state.counter++ 과 같이 기본 상태 값을 직접 변경하면 안되지만redux-toolkit은 알아서 새로운 상태를 복제해(만들어서?) 반환해준다.또 위와 같이 상태를 변경할 때 매개변수를 사용해 변경해야하는 상황이 온다면 payload로 받는다.payload는 기본 값이기 때문에 변경할 수 없다.useDispatch : reducer에 dispatch와 같이 상태를 변경하는 훅useSelector : useDispatch로 상태를 변경한 값을 갖고오는 훅" }, { "title": "[React] useMemo", "url": "/posts/React_useMemo/", "categories": "React", "tags": "React", "date": "2022-07-27 00:00:00 +0900", "snippet": "오늘은 useMemo에 대해서 알아보려고 한다.useMemo 란?React.memo의 인자로 들어간 컴포넌트에 어떤 props가 입력되는지 확인 후입력되는 모든 props의 최신 값을 확인한 뒤 그것을 기존의 props의 값과 비교하도록 리액트에게 전달한다.만약 비교했을 때 props의 값이 바뀐 경우에만 컴포넌트를 재실행하게 된다. 여기서 부모 컴포넌트가 변경되었지만그 컴포넌트의 props의 값이 바뀌지 않았다면 그것은 무시하고 넘어간다.예제 코드 👇const test = (prosp) =&gt; { console.log('hi'); ... return ...}export default React.memo(test); //test의 props 값이 변경되었을 경우 test 컴포넌트를 재실행처음 콘솔로그에는 hi라는 글이 써지지만 만약 props가 변경되지 않으면 그 다음에는 hi라는게 써지지 않는다.만약 test 컴포넌트 아래 자식 컴포넌트가 있다면 당연히 재실행이 되지 않는다.💡 이렇게 달라지지 않으면 재실행하지 않는 이렇게 좋은 훅을 왜 모든 컴포넌트에 적용시키지 않을까?라는 생각이 드는데 이렇게 최적화를 하게 될 때 그 만큼 비용이 따르기 때문이다.이 useMemo 훅은 변경이 발생할 때마다 기존 props 값과 최신의 props 값을 비교합니다.이렇게 매번 비교를 하기 때문에 기존 props 저장공간과 비교하는 작업이 필요하기 때문에 모든 컴포넌트에적용시키지 않는다. 만약 컴포넌트 트리가 매우 크고 useMemo를 사용하는 컴포넌트 위치가 상위에 있다면전체 컴포넌트 트리에 대한 쓸데없는 재실행을 막을 수 있어서 유용하다.반대로 컴포넌트의 변화가 있거나 props의 값이 변화가 드문 경우라면 useMemo는 안쓰는 편이 더 좋다.아래는 React 공식 홈페이지 에 나와있는 useMemo 기본 형식이다.const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);맨뒤에 []로 감싼 a 또는 b 값이 변경되었을 경우 재실행이 된다.다음에는 useMemo와 같이 사용할 수 있는 useCallback에 대해서 포스팅해보려고 한다~!요즘 포스팅을 많이 못쓰게 되었는데,,,귀찮 그래도 꾸준히 해보자 ..! 🔥" }, { "title": "[Algorithm] 합병 정렬", "url": "/posts/merge-sort/", "categories": "Javascript, Algorithm", "tags": "Algorithm, Javascript", "date": "2022-07-16 00:00:00 +0900", "snippet": "오늘은 알고리즘 중 합병 정렬에 대해서 알아보려고 한다.합병 정렬이란?합병 정렬은 이름 그대로 합병과 정렬이라는 두 가지 조합으로 이루어져 있는데 사실 분할, 정렬, 합병이 세 가지가 모두 일어난다.다음을 한 번 봐보자.[3,6,9,5,1,7,2,4] --&gt; 분할[3,6,9,5] [1,7,2,4] --&gt; 분할[3,6] [9,5] [1,7] [2,4] --&gt; 분할[3] [6] [9] [5] [1] [7] [2] [4] --&gt; 정렬[3,6] [5,9] [1,7] [2,4] --&gt; 정렬[3,5,6,9] [1,2,4,7] --&gt; 정렬 및 합병[1,2,3,4,5,6,7,9]이렇게 해서 3가지 일이 일어나는 것이다.다음 코드는 위와 같은 방법은 아니지만 정렬되어 있는 배열을 합병정렬로 정렬하는 방법이다.예제 코드 👇function mergeSort(arr1, arr2) { let result = []; let arr1P = 0; // arr1 배열의 포인터 let arr2P = 0; // arr2 배열의 포인터 while (arr1P &lt; arr1.length &amp;&amp; arr2P &lt; arr2.length) { if (arr2[arr2P] &gt; arr1[arr1P]) { result.push(arr1[arr1P]); arr1P++; } else { result.push(arr2[arr2P]); arr2P++; } } // 두 배열의 크기가 다르면 나머지 부분을 result 배열의 넣는다. while (arr1P &lt; arr1.length) { result.push(arr1[arr1P]); arr1P++; } while (arr2P &lt; arr2.length) { result.push(arr2[arr2P]); arr2P++; } return result;}mergeSort([1, 6, 25], [3, 17, 55, 99]); // result : [1, 3, 6, 17, 25, 55, 99]다음은 정렬까지 포함한 코드로 봐보려고 한다 !! 보기전에 재귀함수에 대해서 알고있으면 이해하기 더 쉽다.💡 맨 위에 숫자로 합병 정렬 방법을 설명한 것도 참고해서 보면 더 이해하기 쉬울 것 같다 !function mergeSort(arr1, arr2) { let result = []; let arr1P = 0; let arr2P = 0; while (arr1P &lt; arr1.length &amp;&amp; arr2P &lt; arr2.length) { if (arr2[arr2P] &gt; arr1[arr1P]) { result.push(arr1[arr1P]); arr1P++; } else { result.push(arr2[arr2P]); arr2P++; } } while (arr1P &lt; arr1.length) { result.push(arr1[arr1P]); arr1P++; } while (arr2P &lt; arr2.length) { result.push(arr2[arr2P]); arr2P++; } return result;}function merge(arr) { if (arr.length &lt;= 1) return arr; // 길이가 1이면 반환 let midP = Math.floor(arr.lengh / 2); // 배열의 중간 지점 포인터 let left = merge(arr.slice(0, mid)); // 재귀 함수 !! let right = merge(arr.slice(mid)); // 재귀 함수 !! return mergeSort(left, right);}merge([56, 32, 96, 74]); // result : [32, 56, 74, 96]위에 코드를 다시 한 번 숫자로 설명하자면 다음과 같다.[56, 32, 96, 74] --&gt; 중간 지점으로 나누기 --&gt; Math.floor(arr.lengh/2)--&gt; merge 함수 호출(재귀함수) merge(arr.slice(0, mid)) --&gt; [56, 32] merge(arr.slice(mid)) --&gt; [96, 74][56, 32] [96, 74] --&gt; 중간 지점 나누기 --&gt; Math.floor(arr.lengh/2)--&gt; merge 함수 호출(재귀함수) merge(arr.slice(0, mid)) --&gt; [56] --&gt; return merge(arr.slice(mid)) --&gt; [32] --&gt; return --&gt; 정렬 !!--&gt; merge 함수 호출(재귀함수) merge(arr.slice(0, mid)) --&gt; [96] --&gt; return merge(arr.slice(mid)) --&gt; [74] --&gt; return --&gt; 정렬 !!이제 아까 정렬된 함수를 합병 시켜주는 mergeSort 함수를 호출 --&gt; mergeSort(left, right)결과 --&gt; [32, 56, 74, 96]재귀함수 부분만 잘 이해할 수 있으면 나머지 부분은 그렇게 어려운 것 같지 않다. 사실 어려움마지막으로 합병정렬의 빅오는 최적, 평균, 최악이 모두 O(nlog n)으로 같다." }, { "title": "[오늘의 배움] 브라우저가 렌더링될 때", "url": "/posts/browserRender/", "categories": "Javascript", "tags": "Javascript, 오늘의배움", "date": "2022-07-15 00:00:00 +0900", "snippet": "오늘은 브라우저가 렌더링 될 때에 대해서 공부해보았다. 전부터 궁금하긴 했는데 이제서야 알아봤다 ㅎㅎ;html파일을 브라우저 렌더링 엔진이 읽을 때 html 문서를 파싱해 브라우저가 이해 할 수 있는 자료구조인 DOM을 생성하게 된다.과정은 서버에 있던 html 파일이 브라우저의 요청에 의해 응답이 되는데 이때 서버는 그 파일을 바이트 단위로 저장 후보내게 된다. 이때 응답 받은 브라우저는 html 문서에 meta 태그의 charset에 의해 인코딩 방식을 기준으로 문자열로 변환된다.그 다음 변환된 html문서를 읽어 들여 토큰들로 분해한다. 여기서 토큰 단위는객체와 비슷하게 전달이 되는데 아래와 같이 전달된다고 한다.{ startTag: 'html', contents: { startTag: 'head', contents: { ... }, ... } endTag: 'html'} // 출처 : 모던 자바스크립트잘보면 html 파일 처럼 html 태그와 head 태그가 보인다.이렇게 토큰 단위로 분해를 한 후 노드로 생성이 된다. 토큰의 따라서 노드는문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성이 된다.그리고 이 노드들을 가지고 트리 구조로 구성하게 되는데 그것을 DOM이라고 한다.이것을 공부하면서 전부터 궁금했던게 풀렸는데 스크립트 파일이 안먹으면 javascript 파일을 로드할 때맨아래에다 넣어라 라고 하는 답변을 많이 봤었다. 그게 왜 그럴까? 했는데 이유는 파싱 과정에서 렌더링 엔진은 html를 한 줄씩 실행하고파싱하면서 javascript 파일을 로드하는 script 태그를 만나면 DOM 생성을 멈추고자바스크립트 파일을 실행하게 된다. 그래서 만약 자바스크립트 파일안에 html 문서의 특정 태그를 조작하는데만약 그 태그를 아직 파싱하지 못했다면 해당 코드를 실행해봤자 아무 일이 일어나지 않는 것이다.이 이유 때문에 javascript 파일을 로드하는 태그는 html문서 맨 아래에 선언해주는게 좋았던 것이였다 !!궁금했을 때 빨리 검색해봤으면 더 빨리 이해할 수 있었을 텐데 이제 와서 알아보았다니,,정말 게을렀던 것 같다 ㅋㅎㅋㅎ" }, { "title": "[오늘의 배움] var vs let, const", "url": "/posts/var_let_const/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-07-08 00:00:00 +0900", "snippet": "어제 ES5와 ES6의 차이점에 이어 var과 let, const의 차이점에 대해서 알아보려고 한다.사실 전에 Scope에 대해서 올렸을 때 이 주제에 대해서 약간 언급한 적이 있다.이 포스팅에서는 좀 더 자세하게 알아보자.var먼저 ES5에서 있었던 var에 대해서 알아보자.var 특징은 중복 선언이 가능하다. 보통 언어들을 보면 중복 선언이 불가능 한데 자바스크립트의 var는 가능하다.예제 코드 👇var name = \"cojaldan\";console.log(name); // result : cojaldanvar name = \"hi\";console.log(name); // result : hi이렇게 중복으로 선언이 되었을 경우 마지막에 할당한 값으로 할당이 된다.심지어 에러도 안난다 ! 이렇기 때문에 var로 선언하면 나중에 오류가 발생할 위험이 있다.var는 함수 레벨 스코프다. 위에 포스팅에서도 언급했지만 함수 안에서만 지역 스코프가 된다.for, if 등도 전역 스코프가 되어 버린다.예제 코드 👇for (var i = 0; i &lt; 3; i++) { console.log(i); // result : 0 1 2}console.log(i); // result : 3이렇게 for문에 i를 선언했지만 for문 밖에서도 값이 잘 나오는 걸 볼 수가 있다.하지만 아래의 경우는 다르다.예제 코드 👇function test() { var i = 10;}console.log(i); // Uncaught ReferenceError: i is not defined위 코드와 같이 함수 안에 i가 선언 되었기 때문에 함수 안에서만 참조가 가능하다.let const다음은 ES6부터 도입된 let, const이라는 키워드이다.let은 var와 다르게 중복선언이 불가능하다.const는 중복선언이 불가능하고 재할당도 불가능하다.예제 코드 👇let test = 1;console.log(test);let test = 2; // test = 2; 이렇게 재할당은 가능하다 !console.log(test); // result : SyntaxError: Identifier 'test' has already been declaredconst test = 1;console.log(test);const test = 1; // test = 1; const로 선언된 변수는 이렇게 재할당도 안된다.console.log(test); // result : SyntaxError: Identifier 'test' has already been declared위와 같이 에러가 발생한다.let과 const의 차이는 재할당을 할 수 있냐 없냐 차이이다. 즉 immutable 차이다.그리고 var는 함수 레벨 스코프 였지만 let과 const는 블록 레벨 스코프를 갖는다.예제 코드 👇for (let i = 0; i &lt; 3; i++) { console.log(i); // result : 0 1 2}console.log(i); // result : ReferenceError: i is not defined이렇게 아까 var와는 달리 에러가 뜬다. 이렇듯 let과 const는 for문, if문 등에서도 지역 스코프를 갖게 된다.또 호이스팅에서도 차이가 나는데 호이스팅에 대한 것은 이곳에서 확인하면 될 것 같다 ㅎㅎ." }, { "title": "[오늘의 배움] ES5 vs ES6", "url": "/posts/ES5_ES6/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-07-07 00:00:00 +0900", "snippet": "오늘은 ES5와 ES6의 차이점에 대해서 알아보려고 한다.ES5와 ES6를 처음 들었을 때 15년에 나온 거랑 16년에 나온건가? 했는데ES5는 2009년에 나왔고 ES6는 2015년에 나온거라고 한다. 😅ES는 ECMASCRIPT를 줄여서 쓴 것이며, 자바스크립트의 표준, 규격을 나타내는 용어이다.그럼 ES5에서 ES6로 업데이트 됐을 때 달라진게 뭐가 있는지 알아보자. let const 추가ES5에서는 var라는 것만 있었는데 ES6부터는 let과 const가 생겨 났다.이 둘의 차이는 스코프가 다르게 동작한다. 스코프에 대한 내용은 이곳에서 확인 하면 될 것 같다 !let과 const에 대한 내용은 다음에 포스팅 해야겠다 ! 화살표 함수 Arrow function또 다른 차이는 화살표 함수가 나왔다.ES5에는 함수 선언문, 표현식, 생성자 함수만 있었는데 ES6부터는 화살표 함수라는 것이 생겨났다.화살표 함수가 무엇이냐?! 아래 코드를 봐보자.예제 코드 👇// 함수 선언문function test(a,b){ }// 함수 표현식var test = function(a,b){ }// 생성자 함수var test = new Function( );// 화살표 함수var test = () =&gt; {};선언하는게 다 비슷비슷하지만 차이가 있긴하다. 차이도 다음에 포스팅 해야겠다 ! 매개변수 초기값 default parameter이건 말 그대로 매개변수에 값을 넣어주지 않아도 초기값을 할당해주면 그 값이 할당되는 것이다.예제 코드를 봐보자.예제 코드 👇const test = (a,b=3) =&gt; { // b에 초기값 3 할당 console.log(a, b);}test(1); // result : 1 3test(2,10); // result : 2 10이렇게 매개변수로 한 개의 값만 줬는데 초기값으로 준 b가 할당 되어서 출력 되는 걸 볼 수 있다.하지만 다른 값을 넣어주면 초기값이 들어가는 것이 아니라 따로 넣어준 값이 할당된다. Template literalES5에서는 문자열을 출력할 때 불편함이 있었다. 어떤 불편함이냐?! 코드로 봐보자.예제 코드 👇console.log('안녕하세요. \\n' + '저는 \\n'+ '코잘단입니다.');//안녕하세요. //저는 //코잘단입니다.console.log(`안녕하세요.저는코잘단입니다.`);//안녕하세요.//저는//코잘단입니다.이렇게 백틱()으로 출력을 하게 되면 \\n` 없이 줄바꿈도 공백도 다 편하게 사용이 가능하다.심지어 백틱으로 묶여진 문자열 안에 ${}로 변수를 묶어주면 변수의 값도 그대로 출력이 된다.예제 코드 👇const test = '코잘단';console.log(`안녕하세요. 저는 ${test}입니다.`); // 안녕하세요. 저는 코잘단입니다.코드도 훨씬 가독성있고 사용도 편하게 됐다.또 디스트럭처링 할당도 도입 되었는데 이곳을 참조 하면 될 것 같다 ! 클래스ES5는 클래스라는 개념은 딱히 없고 그냥 프로토타입 기반이였는데ES6부터는 클래스 가 도입 되었다.예제 코드 👇class Test{ // 생성자, 메서드}클래스는 있다는 것만 알아두고 나중에 공부해서 포스팅 해야겠다 ㅎㅎ…………..망할 할게 왤케 많아😂 모듈script 태그에 type=\"module\" 어트리뷰트를 추가하면 해당 파일은 모듈로 동작한다고 한다.이것도 나중에 공부해서 포스팅 해야겠다……….할게 넘나리 많다..😂😂😂😂😂😂😂😂😂😂😂😂😂😂😂😂😂" }, { "title": "[오늘의 배움] 변수 호이스팅", "url": "/posts/hoisting/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-07-06 00:00:00 +0900", "snippet": "오늘은 Javascript 변수 호이스팅에 대해서 공부해보려고 한다.호이스팅이란?호이스팅이란 사전적 의미로는 감아 올리다라는 뜻이다. 그래서 변수 호이스팅은 변수를 감아 올려진 것처럼 동작한다.var로 선언된 변수는 호이스팅에 의해 선언한 변수 전에도 참조를 할 수 있다.💡 변수에 할당한 값을 가져오는게 아니라 undefined를 반환한다.console.log(test); // result : undefinedvar test = 'test';console.log(test); // result : test이런식으로 동작하는 이유는 자바스크립트 엔진에서 코드들을 한 번 읽는데 그때 변수 호이스팅이 일어나고변수에는 선언 단계와 초기화 단계가 있는데 var로 선언된 변수는 선언과 초기화가 동시에 이루어 지기 때문에선언문 전에 참조를 해도 에러가 나지 않는다.그러면 가독성을 떨어뜨리고 오류를 발생시킬 여지가 남기때문에 var의 단점을 보완하기 위해 ES6부터let과 const가 나왔다. 다음 let의 예제를 봐보자.예제 코드 👇console.log(test); // result : Uncaught ReferenceError: test is not definedlet test = 'test';console.log(test);위 코드에서 var -&gt; let으로 바꿔보았는데 var와 다르게 let으로 선언하니 에러가 발생했다.왜 그럴까?? 이유는 호이스팅이 일어나기는 하지만 발생하지 않는 것처럼 동작하기 때문이다.var는 선언과 초기화가 동시에 일어났지만 let으로 선언된 변수는 선언 단계가 먼저 일어나고초기화해주는 코드를 만나기 전까지 일시적 사각지대(TDZ)가 일어난다. 코드를 봐보자.예제 코드 👇console.log(test); // result : Uncaught ReferenceError: test is not definedlet test;console.log(test); // result : undefinedtest = 'test'console.log(test); //result : test이렇게 동작하기 때문에 변수 호이스팅이 발생하지 않는 것처럼 보이는 것이다.❗ 하지만 const는 선언과 초기화를 동시에 해줘야 한다. 그렇지 않으면 오류가 발생한다.예제 코드 👇const test; // result : Uncaught SyntaxError: Missing initializer in const declaration💡 틀린 부분 지적 부탁드립니다 !!" }, { "title": "[React] Context", "url": "/posts/React_Context/", "categories": "React", "tags": "React", "date": "2022-07-05 00:00:00 +0900", "snippet": "오늘은 React의 Context에 대해서 알아보자.Context 란?리액트에 내장된 state 저장소가 있는데 그것이 리액트 Context라는 개념이다.발그림 😅이 이미지로 설명을 하려고한다. 만약 Context라는 것을 모른다 가정해보자.1-1 컴포넌트에서 로그인에 대한 정보를 얻는다.근데 그 정보를 2 컴포넌트에서 사용한다고 한다. 그럼 1 컴포넌트에 전달 -&gt; App -&gt; 2 컴포넌트에 전달. 이런 로직이 될 텐데,이렇게 예시를 간단하게 해서 이 정도면 할만 하다고 생각하겠지만 만약 더 복잡한 로직이라면 관리하기 힘들 것이고,다른 여러 곳에서 사용해야 한다면 더욱 더 힘들 것이다.그래서 사용하는 것이 Context 라는 개념이다 !Context를 사용한다면 1-1 컴포넌트에서 얻은 로그인에 대한 정보를 Context에 저장 후그 정보를 필요로 하는 컴포넌트에서 바로 가져다 쓰면 된다 !하지만 Context를 항상 사용하는 것은 아니다. state가 짧은 시간에 여러 번 변경되는 경우,Context를 사용한 버튼 같은 컴포넌트는 Context가 없이는 재사용이 힘들기 때문에 사용을 삼가해야한다. context 사용방법Context의 기본 폼은 아래와 같다.const MyContext = React.createContext(defaultValue);매개변수 defaultValue 자리에는 Context로 전달할 값을 넣어주면 된다.예제 코드 👇import React from \"react\";const MyContext = React.createContext({ contextEx: false // 기본값});export default MyContext;이렇게 선언한 후에 필요로하는 컴포넌트를 MyContext로 감싸면 된다.예제 코드 👇&lt;MyContext.Provider value=&gt; ..context를 사용할 컴포넌트들&lt;/MyContext.Provider&gt;그 다음 Context를 사용하려는 컴포넌트에 가서는예제 코드 👇&lt;MyContext.Consumer&gt; {(value) =&gt; {return ( /*JSX코드*/ value.contextEx )}} // 여기서 value는 MyContext.Provider의 값을 가져옴&lt;/MyContext.Consumer&gt;Context는 이렇게 사용하면 되는데 더 간단하게 만들 수도 있다.useContext를 사용하는 것이다 !맨 위에 useContext를 선언 해주고 MyContext를 넣어주면 된다.예제 코드 👇const myContext = useContext(MyContext);이렇게 해주면 Consumer를 사용하지 않고 contextEx 값을 바로 사용할 수 있다.예제 코드 👇import { useContext } from 'react';import MyContext from ...; // 경로에 맞게 넣어준다....const myContext = useContext(MyContext);return ( {myContext.contextEx &amp;&amp;( &lt;div&gt;Hi &lt;/div&gt; )});...이렇게 더 간단하게 Context를 사용할 수도 있다.오늘은 이렇게 Context라는 개념에 대해서 공부해봤는데 리액트는 공부할수록 어려워지는 거 같다 ㅠㅠ💡 틀린 것이 있다면 지적 부탁드립니다 !!!" }, { "title": "[React] Reducer", "url": "/posts/Reducer/", "categories": "React", "tags": "React", "date": "2022-07-04 00:00:00 +0900", "snippet": "오늘은 React 훅 중 하나인 Reducer에 대해서 알아보려고 한다.Reducer란?Reducer란 리액트 내장 훅 중 하나로써 state의 관리를 도와주는 훅이다.엥 ? 😮 useState도 state를 관리해주는데 useReducer도 state를 관리해준다?!둘은 약간 비슷하지만 Reducer에 더 많은 기능이 있고 복잡한 state를 관리 해야 할 때 유용한 훅이다.하지만 state를 관리할 때 항상 reducer를 사용하는 것은 아니다.사용하기에 좀 더 복잡하기도 하고 설정이 필요하다.그래서 너무 복잡한 state를 관리하는 것이 아니라면 useState를 사용하는 것이 좋다. reducer 사용방법Reducer를 사용할 때 기본 형식은 아래와 같다.const [state, dispatch] = useReducer(reducerFunction, initialState);💡 형식은 이게 기본 형식이지만 변수 이름은 마음대로 해도 상관은 없다.Reducer도 항상 두개의 값이 있는 배열을 반환하는데, Reducer는 state를 관리하는 훅이기 때문에위 코드의 state는 최신 state가 된다. 그리고 그 state를 업데이트할 수 있게 해주는 함수인 dispatch를 반환한다.reducerFunction은 최신 state를 가져오는 함수이다.initialState는 말 그대로 state의 초기 값을 설정해주는 것이다.자 이제 reducer를 코드로 한번 봐보자.예제 코드 👇import React, { useReducer } from 'react';function reducer(state, action) { // 최신 값을 가져다 주는 reducer함수 switch (action.type) { case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; }}function Counter() { const [number, dispatch] = useReducer(reducer, 0); // number의 초기값으로 0을 설정 const onIncrease = () =&gt; { dispatch({ type: 'INCREMENT' }); // number를 업데이트 해주는 함수 }; const onDecrease = () =&gt; { dispatch({ type: 'DECREMENT' }); // number를 업데이트 해주는 함수 }; return ( &lt;div&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={onIncrease}&gt;+1&lt;/button&gt; &lt;button onClick={onDecrease}&gt;-1&lt;/button&gt; &lt;/div&gt; );}export default Counter;출처 : 벨로퍼트님 리액트 깃북+1이라는 버튼을 누르면 onIncrese 함수에서 state를 업데이트 해주는 함수인 dispatch를 호출 한다.그리고 reducer 함수에서 전달된 값에 맞게 state를 업데이트 해주고 최신 state를 반환하고 페이지에 보여준다.이렇게 오늘은 간단한 코드로 reducer라는 것을 알아보았다.아까 위에서 말한 것 처럼 위 코드 같이 간단한 코드는 useState를 사용해 관리하는게 편해보이고더 복잡한 코드를 다룰 때 useReducer를 사용하는게 더 나아 보인다 😄더 복잡한 코드를 잘 다룰 수 있을 때 까지 열심히 공부 해야겠다 ! 💪😁" }, { "title": "[알고리즘] 삽입정렬", "url": "/posts/insertSort/", "categories": "Javascript, Algorithm", "tags": "Javascript, Algorithm", "date": "2022-07-03 00:00:00 +0900", "snippet": "오늘은 삽입정렬에 대해서 공부해보았다.삽입정렬이란?한 번에 하나의 항목을 선택해 그 항목을 올바른 위치에 삽입해서 배열을 정렬하는 방법이다.시간복잡도는 최선의 경우는 O(n)이지만 최악의 경우에는 O(n^2)의 시간 복잡도를 갖는다.삽입정렬은 정렬이 거의 다 된 배열에선 매우 효율적이고 반대로 역순에 가까우면 매우 비효율적인 정렬 방법이다. 정렬 방법여기선 조금이라도 더 알아보기 쉽게 왼쪽값 오른쪽값으로 설명하겠다.오른쪽 값을 임의의 변수에 저장해두고 바로 왼쪽 값과 비교해 만약 왼쪽 값이 더 크면 오른쪽 값에 왼쪽 값을 넣은 후오른쪽 값을 저장해 두었던 변수로 왼쪽에 다시 값을 대입해준다. 만약 오른쪽 값이 더 크다면 그대로 둔다.삽입 정렬은 이런 식으로 동작을 한다. 말로는 역시 이해하기 여러우니 코드로 봐보자.예제 코드 👇function insertSort(arr){ for(let i = 1; i&lt;arr.length; i++){ let currentValue = arr[i]; // 오른쪽 값을 임의의 변수에 저장 for(let j = i-1; j&gt;=0; j--){ if(arr[j] &gt; currentValue){ // 오른쪽 값이랑 왼쪽 값을 비교 arr[j+1] = arr[j]; // 왼쪽이 더 크다면 오른쪽 값에 왼쪽 값을 넣은 후 arr[j] = currentValue; // 오른쪽 값을 저장해 두었던 변수로 왼쪽에 넣어준다. } } } return arr;}insertSort([44,1,35,7,3,46,32,15,0]); // result : [0, 1, 3, 7, 15, 32, 35, 44, 46]이렇게 삽입정렬 코드를 짤 수 있다. 이것보다 더 나은 코드가 있겠지만 조금의 도움이라도 됐으면 좋겠다..!" }, { "title": "[알고리즘] 선택정렬", "url": "/posts/Select/", "categories": "Javascript, Algorithm", "tags": "Javascript, Algorithm", "date": "2022-07-02 00:00:00 +0900", "snippet": "오늘은 선택정렬에 대해서 알아보자.선택 정렬은 버블 정렬과 조금 비슷하다.선택정렬이란?배열의 수들을 하나씩 비교해 가며 최소값을 배열의 맨 앞에 위치시키는 것이다.처음엔 배열의 첫 번째 값이 가장 작은 값으로 시작한다.그리고 바로 다음 값과 비교한다. 만약 다음 값이 더 작으면 그 값을 가장 작은 값으로 설정한다.만약 더 작지 않다면 그 다음 값과 비교한다. 이렇게 하나하나 비교해 가면서 최소값을 찾는 것이다. 💡 값을 저장할 때는 해당 값을 저정하는 것이 아니라 인덱스 값을 저장한다.역시 말로는 이해하기 힘드니 코드로 봐보자.예제 코드 👇function selection(arr) { for(let i=0; i&lt;arr.length; i++){ let low = i; // 배열의 첫 번째 인덱스를 최소값으로 설정 for(let j=i+1; j&lt;arr.length; j++){ // 다음값을 비교해야하므로 i+1 부터 시작 if(arr[low] &gt; arr[j]){ // 최소값보다 다른 값이 크면 low = j; // 최소 인덱스로 다시 설정 } } if(i !== low){ // i와 최소값이 같아도 교환하는 것을 방지하기 위한 조건 let temp = arr[i]; arr[i] = arr[low]; arr[low] = temp; } } return arr;}selection([13,6,12,42,75,33,65]); // result : [6, 12, 13, 33, 42, 65, 75]이렇게 선택 정렬이 끝이난다 !!이 정렬은 그렇게 어려운게 아니라 쉽게 쉽게 한 것 같다.설명이 조금 부족한 것 같은데 그래도 도움이 됐으면 좋겠다." }, { "title": "[오늘의 배움] 이터러블", "url": "/posts/iterable/", "categories": "Javascript, 오늘의배움", "tags": "Javascript, 오늘의배움", "date": "2022-07-01 00:00:00 +0900", "snippet": "오늘은 이터러블에 대해서 알아보려고 한다.이터러블이란?이터러블 프로토콜을 준수한 객체를 이터러블이라고 한다.💡 이터러블 프로토콜이란?javasciprt에서 기본 제공하는 빌트인 심벌 값인 Symbol.iterator를 프로퍼티 키로 사용한 메서드를직접 구현하거나 Symbol.iterator를 호출하면 이터레이터를 반환하는 것이다.쉽게 말하면 for of 메서드로 순회 가능한 객체인것이다.String, Array, 문자열, Map, Set 등은 이터러블이다.전에 올렸던 Map, Set에서 말했던 것 처럼 for of문으로 순회 할 수 있고, 스프레드 문법과디스트럭처링 할당을 할 수 있다.예제 코드 👇let arr = [1,2,3];for(const item of arr){ console.log(item); // result: 1 // 2 // 3}console.log([...arr]); // result : [1, 2, 3]console.log(...arr); // result : 1 2 3어떤 객체가 이터러블인지 아닌지 확인하는 방법 중 하나는 아래 이미지 처럼Symbol.iterator를 상속받았냐 안받았냐 차이도 있다.이 이미지는 위에 코드 중 arr 변수이다.오늘은 짧게 이터러블에 대해서 알아보았다. 다음엔 이터레이터라는 것에 대해서 공부하려고 한다.이터러블은 단순한 거 같아도 막상 읽어보면 이해하기 어려운 개념인 거 같다…." }, { "title": "[오늘의 배움] Map", "url": "/posts/Map/", "categories": "Javascript, 오늘의배움", "tags": "Javascript, 오늘의배움", "date": "2022-06-30 00:00:00 +0900", "snippet": "오늘은 저번에 공부했던 Set에 이어서 Map이라는 것을 공부하려고 한다.Map 이란?Map은 키와 값을 쌍으로 하는 객체이다. Map은 키로 객체를 포함한 모든 값을 사용할 수 있다. Map 사용법다음은 Map의 사용법에 대해서 알아보자.예제 코드 👇let map = new Map();console.log(map); // result : Map(0) {size: 0}Set 처럼 간단하다 ㅎㅎ매개변수로 아무것도 안주면 위 코드 결과 처럼 생성이 되고 매개변수에 이터러블로 받아 Map을 생성한다.예제 코드 👇let map = new Map([['name', 'lee']]);console.log(map); // result : Map(1) {'name' =&gt; 'lee'}위 코드 처럼 키와 값의 쌍으로 주어야 생성이 된다.예제 코드 👇let map = new Map(['name', 'lee']);console.log(map); // Uncaught TypeError: Iterator value name is not an entry object위 코드 처럼 그냥 name과 lee를 전달해버리면 에러가 난다.주의 ❗ Map은 중복된 키를 갖지 못해 만약 중복된 키가 들어온다면 나중에 들어온 키와 값으로 덮어써버린다.요소의 개수는 Set과 똑같이 size 메서드를 사용하고 Map도 getter만 있어 사이즈를 변경하고 싶어도 하지 못한다. 요소 추가Map의 요소 추가 방법은 set 메서드로 추가가 가능하다.예제 코드 👇let map = new Map();console.log(map); // result : Map(0) {size: 0}map.set('name', 'lee');console.log(map); // result : Map(1) {'name' =&gt; 'lee'}Map도 Set과 마찬가지로 요소 추가하는 set메서드는 Map객체를 반환하므로 메서드 체이닝이 가능하다. 요소 얻는 방법Map 객체에 요소를 얻는 방법은 get 메서드를 사용하면 된다.get 메서드의 매개변수로는 키를 전달하여 요소를 얻는다.예제 코드 👇let map = new Map([['name', 'lee']]);console.log(map.get(name)); // result : leelet test = { name : 'cojaldan' };map.set(test, 'dev'); // Map 객체에 키 값으로 제한이 없으므로 객체로도 가능하다.console.log(map.get(test)); // result : dev 요소 삭제요소를 삭제하는 방법은 Set과 똑같이 delete 메서드를 사용한다.삭제할 때 매개변수로는 키 값을 넣으면 된다.일괄삭제도 마찬가지로 clear를 사용한다.예제 코드 👇let map = new Map([['name', 'lee']]);let test = { name : 'cojaldan' };map.set(test, 'dev');console.log(map); // result : Map(2) {'name' =&gt; 'lee', {…} =&gt; 'dev'}map.delete('name');console.log(map); // result : Map(1) { {…} =&gt; 'dev'}map.clear();console.log(map); // result : Map(0) {size: 0} 요소 순회Map 객체는 이터러블이므로 for of문으로 순회가 가능하고 스프레드 및 디스트럭처링 할당도 가능하다.Map 메서드에는 keys, values, entries가 있는데 예제 코드로 봐보자.예제 코드 👇let map = new Map();let test = { name : 'cojaldan' };map.set(test, 'dev');for(const key of map.keys()){ // 키를 조회 console.log(key); // result : {name: 'cojaldan'} }for(const value of map.values()){ // 요소 값을 조회 console.log(value); // result : dev}for(const entry of map.entries()){ // 키와 요소값을 조회 console.log(entry); // result : [{name: 'cojaldan'}, 'dev']}오늘은 Map에 대해서 알아보았다.공부한걸로 실무에서 잘 써먹을 수 있을지 모르겠지만 잘 기억해보자 ! 🔥" }, { "title": "[React] useEffect", "url": "/posts/useEffect/", "categories": "React", "tags": "React", "date": "2022-06-29 00:00:00 +0900", "snippet": "오늘은 리액트의 중요한 개념인 useEffect에 대해서 알아보려고 한다.useEffect 란?useEffect는 리액트가 제공해주는 기본 hook중 하나이다.useEffect는 컴포넌트가 렌더링 될 때 어떤 일을 실행할 수 있게 해준다.근데 무조건 그 일을 실행하는 것이 아니라 렌더링 되는 경우가 따로 있다. 컴포넌트가 렌더링 되고 난 후 한번만 실행되는 경우 useEffect에 지정한 값이 변경이 되는 경우물론 이거 말고 더 있을 수 있으나,, 지금 공부한건 이 두가지이다. ㅠ.,ㅠuseEffect는 두개의 매개변수와 함께 호출되는데첫 번째는 함수 두 번째는 지정할 값을 넣으면 된다.여기서 두 번째에 넣은 값이 변경될 때마다 첫 번째에 넣었던 함수가 실행되는 것이다 !!한 번 코드를 보고 다시 이해해 보자.예제 코드 👇... 코드 생략useEffect(() =&gt; { // 1번 console.log('EFFECT RUNNING'); return () =&gt; { // 2번 console.log('EFFECT CLEANUP'); }}, []);useEffect(() =&gt; { // 3번 const timer = setTimeout(()=&gt;{ console.log('Check form'); setFormIsValid( enteredEmail.includes('@') &amp;&amp; enteredPassword.trim().length &gt; 6 ); }, 500); return () =&gt; { // 4번 console.log('CLEANUP'); clearTimeout(timer); }}, [enteredEmail, enteredPassword]); ... 코드 생략이 코드에는 안나와 있지만 3번 코드에 두 번째 매개변수로 enterdEmail, enteredPassword가 들어가 있는데이게 enterdEmail, enteredPassword 이 두 가지 중 변경되는 값이 있으면 3번의 함수를 실행한다는 것이다.만약에 1번 useEffect와 같이 지정한 값이 없으면 맨 처음 렌더링 될 때 한 번 실행이 된다.근데 여기서 2번과 4번 처럼 반환 되는 함수가 있는데 이걸 cleanup 함수 라고한다.만약 cleanup 함수가 지정 되어 있다면 컴포넌트가 언마운트가 될 때, 업데이트가 되기 직전에 cleanup 함수가 실행된다.여기서 2번 처럼 두 번째 매개변수가 빈 배열이라면 컴포넌트가 언마운트 될 때 실행이 되고,4번 처럼 두 번째 매개변수에 값을 지정해주었다면 지정해준 값이 업데이트가 되기 직전에 cleanup 함수가 실행된다.또 ❗ 만약에 이렇게 사용하지는 않는다고 하지만 두 번째 매개변수에 아무것도 넣지 않는다면예제 코드 👇useEffect(() =&gt; { console.log('EFFECT RUNNING');});렌더링 될 때 마다 실행이 된다.이렇게 오늘은 useEffect에 대해서 알아보았다.리액트는 공부하면 할수록 더 어려워 지는 것 같다,, 😥" }, { "title": "[오늘의 배움] Set", "url": "/posts/Set/", "categories": "Javascript, 오늘의배움", "tags": "Javascript, 오늘의배움", "date": "2022-06-28 00:00:00 +0900", "snippet": "Set 이란?Set은 중복되지 않는 유일한 값들의 집합이다.Set은 배열과 유사하지만 몇가지 차이점이 있다. 동일한 값이 중복되어 있을 수 없다. 요소들의 순서는 의미 없다. 인덱스로 요소에 접근이 불가능하다.Set 객체를 생성하는 방법은 코드로 살펴보자.예제 코드 👇let set = new Set();console.log(set); //result : Set(0) {size: 0}Set을 선언하는 방법은 위와 같이 간단하다.값을 추가하는 방법은 생성할 때 매개변수로 주면되는데 주의할 점은 이터러블로 줘야한다.또 다른 방법은 add를 사용해 값을 넣을 수가 있다.add 메서드를 사용했을 때 반환값이 set 객체를 반환하기 때문에 메서드 체이닝을 활용해 여러번 추가가 가능하다.코드로 봐보자.예제 코드 👇let set = new Set([1,2,3]);console.log(set); // result : Set(3) {1, 2, 3}set.add(4).add(5);console.log(set); // result : Set(5) {1, 2, 3, 4, 5}set.add(3); // 3은 이미 있으므로 변화하는 건 없다 !console.log(set); // result : Set(5) {1, 2, 3, 4, 5}console.log(set.size); // result : 5Set은 값의 중복을 허용하지 않아서 이미 있는 3을 넣었을 때 변화가 없는 걸 볼 수가 있다.요소의 개수를 확인할 때는 size를 사용하면 확인할 수 있다.size 프로퍼티는 setter는 없고 getter만 있어서 요소 개수를 변경하고 싶어도 할 수 없다 !! 요소 확인요소를 확인하는 방법은 has 메서드를 사용하면 된다. 반환값은 true, false이다.예제 코드 👇let set = new Set([1,2,3]);console.log(set.has(3)); // result : true 있을 경우 trueconsole.log(set.has(4)); // result : false 없을 경우 false 요소 삭제추가하는 방법은 알았으니 이제 삭제하는 방법을 알아보자.삭제하는 방법도 간단하다 delete 메서드를 사용하면 된다!반환값은 성공이면 true 실패(해당 요소가 없으면)면 false를 반환한다.예제 코드 👇let set = new Set([1,2,3]);console.log(set.delete(1)); // result : trueconsole.log(set.delete(4)); // result : falseconsole.log(set); // result : Set(2) {2, 3}여기서 주의할 점은 !! delete 메서드에 인덱스 값을 주는 것이 아닌 Set 객체 안에 요소의 값을 줘야한다.근데 이렇게 하나하나 삭제해줘야하냐!? 그건 아니다 ❌clear 메서드를 사용하면 한번에 다 지워줄 수 있다.예제 코드 👇let set = new Set([1,2,3]);console.log(set); // result : Set(3) {1, 2, 3}console.log(set.clear()); // result : undefined // clear 메서드는 언제나 undefined를 반환한다.마지막으로 Set 메서드는 이터러블 이므로 for of로는 순회가 불가능하고 (불가능이 아니라 가능이다 ㅠㅠ)스프레드 문법 또는 디스트럭처링 할당으로 요소 확인이 가능하다.예제 코드 👇let set = new Set([1,2,3]);console.log(...set); // result : 1 2 3오늘은 Set 이라는 것에 대해 알아보았다. 물론 위에 적혀있는 거 말고도 더 많은개념들이 있겠지만,, 이 정도만 알아보려고 한다. 다음 공부하다가 새로 배우는 것이 있으면추가적으로 올려야겠다 ~! 🔥" }, { "title": "[오늘의 배움] 디스트럭처링 할당", "url": "/posts/destructuring/", "categories": "Javascript, 오늘의배움", "tags": "Javascript, 오늘의배움", "date": "2022-06-27 00:00:00 +0900", "snippet": "오늘은 자바스크립트의 디스트럭처링 할당에 대해서 알아보려고 한다.개념은 간단한데 여기저기 많이 쓰이는 것 같아 알아두면 좋지 않을까 생각이 된다 😄디스트럭처링 할당이란?디스트럭처링 할당은 다른말로 구조 분해 할당이라고 한다. 할당할 때 이터러블을 할당하지 않으면 에러가 발생한다.디스트럭처링을 MDN에서는 이렇게 정의하고 있다.` 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다.`이게 무슨 말이냐?! 예제 코드로 이해해보자.예제 코드 👇let arr = [1,2,3];// 원래 배열 안에 값을 변수에 저장하려면 아래 처럼 하나하나 저장을 했어야 했다.let one = arr[0];let two = arr[1];let three = arr[2]; // 하지만 디스트럭처링 할당을 사용하면 아래와 같다.let [ one1, two1, three1 ] = arr;console.log(one, two, three, one1, two1, three1); // result : 1 2 3 1 2 3할당 될 때 위와 같이 순서대로 할당이 되는데 변수의 개수와 우변의 개수가 일치할 필요는 없다.예제 코드 👇let [a, , c] = [1,2,3];console.log(a, c); //result : 1 3 자리에 맞게 저장이 된다. 디스트럭처링 변수 기본값 설정디스트럭처링 할당을 할 때 기본값을 설정할 수도 있다.예제 코드로 봐보자.예제 코드 👇let [a, b, c=3] = [1, 2];console.log(a, b, c); //result : 1 2 3let [d, e, f=1] = [1,2,3]; console.log(d, e, f); // result : 1 2 3 기본값보다 할당된 값을 우선한다. 객체 디스트럭처링 할당디스트럭처링 할당은 객체로도 할당이 가능하다. 객체로 할당하는 경우에도 객체로 할당하지 않으면 에러가 발생한다.객체를 할당하는 기준은 프로퍼티 키이다.바로 예제 코드로 봐보자.예제 코드 👇let test = { a:10, b:20 };let { a, b } = test;console.log(a, b); // result : 10 20객체를 할당하는데 이렇게도 활용이 가능하다.예제 코드 👇let str = 'test';let { length } = str;console.log(length); // result : 4str는 String으로 선언되었기 때문에 String 래퍼 객체를 사용할 수 있다.따라서 String 객체의 length를 할당한 것이다.오늘은 디스트럭처링 할당에 대해서 알아보았다. 리액트를 공부하다가 이 디스트럭처링 할당에 대해서 나왔는데처음엔 이게 뭐지 하고 어려웠는데 공부해보니 꽤 간단한 개념이였다. 오늘도 화이팅 해보자 !! 🔥" }, { "title": "[오늘의 배움] Symbol", "url": "/posts/Symbol/", "categories": "Javascript, 오늘의배움", "tags": "Javascript, 오늘의배움", "date": "2022-06-22 00:00:00 +0900", "snippet": "오늘은 Symbol(심벌)이라는 것에 대해서 공부해보자.심벌이란?심벌이란 ES6에서 도입된 데이터 타입으로 변경이 불가능한 원시 타입의 값이다.심벌로 선언한 값은 다른 값과 중복되지 않는 단 하나만 있는 값이다. 그래서 주로이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다. 심벌 선언심벌 값을 선언 하는 방법은 Symbol 함수를 호출하여 생성할 수 있다.심벌의 값은 외부로 노출되지 않아 확인할 수 없다.그리고 Symbol 함수로 선언된 것들은 키와 심벌 값을 쌍으로 전역 심벌 레지스트리에 값을 저장한다.예제 코드로 선언하는 방법을 봐보자.예제 코드 👇let test = Symbol(); // 이렇게 선언하면 끝이다 너무 간단하다..let test2 = new Symbol(); // Uncaught TypeError: Symbol is not a constructor// new 연산자와 함께 선언하려고하면 에러가 난다.let test3 = Symbol('test');let test4 = Symbol('test');console.log(test3 === test4); // result : false 값에 대한 설명이 같더라도 심벌로 선언된 값은 유일한 값이다.심벌 값은 암묵적으로 문자나 숫자 타입으로 변환이 되지 않는다.let test = Symbol();console.log(test + ''); // Uncaught TypeError: Cannot convert a Symbol value to a stringconsole.log(+test); // 스크립트 스니펫 #36:14 Uncaught TypeError: Cannot convert a Symbol value to a number Symbol 메서드Symbol 함수의 메서드에는 for과 keyFor 메서드가 있다.Symbol.for 메서드는 매개변수로 받은 문자열을 키로 사용해 아까 말한 전역 심벌 레지스트리에서 해당 키와일치하는 심벌 값을 검색한다.검색된 값이 있으면 새로 심벌 값을 생성하지 않고 검색한 심벌 값을 반환한다.만약 실패하면 새로운 심벌 값을 생성해 매개변수로 받은 것을 키로 전역 심벌 레지스트리에 저장한 후 생성된 값을 반환한다.예제 코드로 위 설명을 확인해 보자예제 코드 👇let a = Symbol.for('test');let b = Symbol.for('test');console.log(a === b); // result : trueSymbol.keyFor 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.예제 코드 👇const s1 = Symbol.for('mySymbol');Symbol.keyFor(s1); // result : mySymbol심벌 값은 유일무이한 값이므로 자바의 enum과 비슷하게 사용할 수도 있다.오늘 심벌에 대해서 알아보았는데 역시 자바스크립트는 어려운 것 같다…심벌은 다음에 더 공부해서 추가적으로 기록을 남겨야할 거 같다..! 🔥" }, { "title": "[React] useRef", "url": "/posts/React_useRef/", "categories": "React", "tags": "React", "date": "2022-06-21 00:00:00 +0900", "snippet": "오늘은 리액트의 훅중 하나인 useRef에 대해서 공부해보려고 한다.원래 앞에 내용도 공부해야하는데 먼저 메모한 useRef부터 남겨야 겠다 ㅎㅎ;;useRef 란?사용자 입력에 접근할 수 있는 또는 특정 DOM을 가리킬 때 사용하는 hook 중 하나이다.이것을 사용할 때는 특정 DOM에 대한 포커스, 엘리먼트 크기나 색상을 변경할 때 사용한다.useRef는 자바스크립트에서 많이 사용하는 getElementById 같은 특정 DOM을 선택하는 것이라고 생각하면 될 것 같다.사용자 입력을 state로 관리할 수 있지만 useRef를 사용하면 간단하게 접근이 가능하다.⭐ 사용자 입력을 변경할 때 useRef를 사용하는 것은 아니다 ! useRef로는 값을 읽기만 하고 변경하지 않는다.사용 방법은 useState처럼 상단에 import { useRef } from ‘react’; 라고 선언해 주면 된다.그리고 const 변수명 = useRef(); 라고 하고 가리키고 싶은 태그에 ref={변수명}을 추가 해주면 끝이다 ! 매우 간단하다 🤷‍♀️ref는 항상 객체이고 안에 current 라는 프로퍼티를 항상 갖고있다.current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다.오늘도 역시 코드로 한번 봐보자.예제 코드 👇import React, { useRef } from 'react'; // 상단에 선언const AddUser = (props) =&gt; { const inputRef = useRef(); // 가리킬 DOM을 갖고올 변수 선언 ...생략 return ( &lt;div&gt; ...생략 &lt;input id=\"username\" type=\"text\" ref={inputRef} /&gt; // 가리킬 DOM 설정 &lt;/div&gt; );}export default AddUser;이 코드 처럼 위에 변수를 useRef 변수를 선언해주고 가리키고 싶은 태그에 ref={변수명}을 넣어주면 끝이 난다.이제 current를 사용해 로그를 찍어보면 input 태그에 입력한 값이 찍히는 걸 볼 수가 있다.inputRef.current.value = 'hello world'; 이런식으로 값을 변경할 수 있지만 위에서 말했듯이 잘 사용하지 않는다.오늘은 이렇게 useRef에 대해서 알아보았는데 아직 많이 부족한 것 같다,,사실 앞부분도 잘 모른다,, 그래도 일단 쭉 공부하고 다시 복습하는 식으로 해야겠다." }, { "title": "[오늘의 배움] 클로저 Closure", "url": "/posts/Closure/", "categories": "Javascript", "tags": "Javascript, 오늘의배움", "date": "2022-06-20 00:00:00 +0900", "snippet": "오늘은 전에 스코프 공부할 때 알아보기로한 클로저에 대해서 공부해보자 ✍클로저에 대해서 공부하기 전에 렉시컬 스코프가 뭔지 알고 있어야 한다고 한다 !!제가 렉시컬 스코프 에 대해서 올린 글을 먼저 보고 오면 좋을 것 같다.클로저란?클로저는 자바스크립트에서만이 아니라 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는중요한 특성이다.클로저를 말로 간단하게 설명하자면 외부함수에서 선언한 변수가 있는데 외부함수의 실행이 끝나서도내부함수에서 외부함수의 변수에 접근(참조)할 수 있는 것이다.코드로 다시 한번 봐보자.예제 코드 👇const a = 1;function test(){ const a = 2; function test2(){ console.log(a); } return test2();}const test3 = test(); test3; // result : 2위 코드를 보면 test 함수를 호출하면 test2 함수를 반환하고 실행 컨텍스트 스택에서 제거가 된다.그럼 이때 test함수의 지역변수인 a도 마찬가지로 생명주기를 마감한다. 하지만 위 코드를 실행해보면2라는 결과가 나온다. 이 코드와 같이 외부함수의 실행이 끝나 컨텍스트 스택에서 제거가 됐는데도내부함수에서 값이 1인 전역변수 a를 접근하는게 아니라 test 함수의 지역변수 a를 참조한다.다시 말해 클로저란 내부함수가 외부함수의 지역변수에 접근 할 수 있고, 외부함수의 생명주기가 끝나도내부함수의 생명주기가 끝날 때 까지 외부함수의 변수에 접근할 수 있는 것을 말한다.클로저란 개념을 쉽게 봤는데 공부해보니까 꽤나 어려운 개념이였다 இдஇ더 잘 알때 까지 반복해서 공부해보자 🔥참조 : 모던 자바스크립트 Deep Dive / MDN / 생활코딩" }, { "title": "[오늘의 배움] Lexical Scope", "url": "/posts/Lexical_Scope/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-06-19 00:00:00 +0900", "snippet": "오늘은 Lexical Scope(렉시컬 스코프)라는 것을 공부해보자 ✍렉시컬 스코프란?함수를 어디서 정의 했는지에 따라 상위 스코프를 결정하는 것이다.같은 말로는 Static Scope(정적스코프)라고도 한다.📌 참고 : 함수를 어디서 호출했는지에 따라 함수의 상위스코프를 결정하는 것은 동적 스코프라고 한다.자바스크립트는 렉시컬 스코프를 따르기 때문에 여기서는 렉시컬 스코프를 설명하겠다 !!코드로 다시 한 번 봐보자예제 코드 👇var val = 1;function test(){ var val = 10; test2(); // 출력 1}function test2(){ console.log(val); // 출력 2}이렇게 코드를 짰을 때 출력 1과 출력 2의 값은 어떻게 나올까?나는 처음 당연히 출력 1 에선 10이라는 결과가 나올 줄 알았고 출력 2 에선 1이라는 결과가 나올 줄알았는데 출력 1 과 출력 2 에선 둘다 1이라는 결과가 나왔다. 엥 ( ꒪⌓꒪)?위에서 말한 것 처럼 자바스크립트는 렉시컬 스코프를 따르기 때문에 1이라는 결과 값이 나온 것이다.즉 test2 함수는 자신이 정의된 전역 스코프를 참조하기 때문에 전역 변수 x를 접근(참조)한다.렉시컬 스코프는 클로저와 관련이 있어서 다음에는 클로저에 대해서 공부를 해봐야 겠다. ✍" }, { "title": "[알고리즘] 버블정렬", "url": "/posts/Bubble_sort/", "categories": "Javascript, Algorithm", "tags": "Algorithm, Javascript", "date": "2022-06-19 00:00:00 +0900", "snippet": "오늘 알고리즘은 버블 정렬에 대해서 알아보려고 한다.버블 정렬이란?버블 정렬의 빅오표기법은 O(n^2)으로 데이터가 많으면 매우 오래걸리는 정렬이고 정렬이 거의 다 된배열을 정렬한다고 하면 매우매우 비효율 적인 정렬 방법이다.만약 [1,6,2,3,7] 이라는 배열을 정렬한다고 하자.버블 정렬은 첫 번째 데이터(1)와 바로 옆에 있는 데이터(6)와 비교해 크면 자리를 바꾸고 아니면 옆 데이터(6)와 그 옆에 데이터(7)를 비교해나가면서 정렬하는 정렬 방법이다.말로 설명하는 건 잘 이해가 되지 않으니 바로 예제 코드로 봐보자.예제 코드 👇function bubble(arr){ for(let i=0; i&lt;arr.length; i++){ for(let j=0; j&lt;arr.length; j++){ if(arr[j] &gt; arr[j+1]){ // 바로 옆 데이터와 비교 let temp = arr[j]; // 크면 서로 데이터를 바꾸기 위해 임시 변수에 데이터를 넣는다. arr[j] = arr[j+1]; // 데이터 교체 arr[j+1] = temp; } } } return arr;}위 예제 코드 처럼 배열의 데이터들을 전부 비교해가며 정렬을 한다.근데 ❗ 위에 코드를 실행할 때 로그를 한번 찍어보면 마지막 수를 비교할 때 undefined와 비교하는 걸 볼 수가있다. 그래서 두번째 반복문이 돌 때도 이미 정렬된 마지막 데이터까지 비교하는 것도 볼 수가 있다. 이것을최적화한 코드를 다시 짠다면 이렇게 될 것 같다.예제 코드 👇function bubble(arr){ for(let i=arr.length; i&gt;0; i--){ for(let j=0; j&lt;i-1; j++){ if(arr[j] &gt; arr[j+1]){ // 바로 옆 데이터와 비교 let temp = arr[j]; // 크면 서로 데이터를 바꾸기 위해 임시 변수에 데이터를 넣는다. arr[j] = arr[j+1]; // 데이터 교체 arr[j+1] = temp; } } } return arr;}이 코드에서 한번 더 최적화를 한다면 이런 코드일 것이다 !!function bubble(arr){ let fin; for(let i=arr.length; i&gt;0; i--){ fin = true; for(let j=0; j&lt;i-1; j++){ if(arr[j] &gt; arr[j+1]){ // 바로 옆 데이터와 비교 let temp = arr[j]; // 크면 서로 데이터를 바꾸기 위해 임시 변수에 데이터를 넣는다. arr[j] = arr[j+1]; // 데이터 교체 arr[j+1] = temp; fin = false; // 만약 교환이 이루어지면 false } } if(fin) break; // 교환이 이루어지지 않았다하면 true로 들어와 반복문 종료 ! } return arr;}이것으로 버블정렬과 버블정렬을 최적화한 코드까지 공부해보았다.다음에는 선택정렬이라는 정렬 방법에 대해서 알아봐야겠다. (๑˃̵ᴗ˂̵)ﻭ" }, { "title": "[오늘의 배움] Scope", "url": "/posts/Scope/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-06-18 00:00:00 +0900", "snippet": "오늘은 Scope 이라는 것에 대해서 알아보도록 하자. Scope(스코프) 란?Scope는 범위라는 뜻을 가지고 있다. 즉 스코프라는 것은 변수에 접근(참조)을 할 수 있는 범위라고 생각하면 될 것 같다.ES6 부터 나온 let과 const 그리고 var 키워드로 선언한 변수의 스코프는 다르게 동작하기 때문에 잘 알아두는 것이 좋을 것 같다.바로 예제 코드로 알아 보자예제 코드 👇var a = 1;if(true){ var b = 1; if(true){ var c = 1; }}function test(){ var d = 1; function test2(){ var e = 1; }}console.log(a); // result : 1console.log(b); // result : 1console.log(c); // result : 1console.log(d); // result : ReferenceError .. console.log(e); // result : ReferenceError ..위와 같이 모든 식별자들은 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 범위가 결정된다.다음은 스코프의 종류에 대해서 알아보자. 스코프의 종류스코프의 종류로는 지역과 전역이 있다.전역스코프는 말 그대로 전역에서 접근(참조)이 가능한 스코프이고 지역 스코프는 함수 내부에서 접근이 가능한 스코프이다.말로만 하면 이해가 잘 되지 않을 수도 있으니 바로 예제 코드로 봐보자예제 코드 👇var a = 1; // 이것이 전역에 선언된 변수이다.function test(){ var b = 1; // 이것이 지역에 선언된 변수이다.}console.log(a); // result : 1 전역에 선언된 변수는 접근(참조)가 가능해서 1이라는 결과가 잘 나온다.console.log(b); // ReferenceError: b is not defined 지역에 선언된 변수는 접근(참조)이 불가능 해서 에러가 뜬다 !!또 다른 예제 코드도 보자 !!예제 코드 👇var a = 1;function test(){ console.log(a); }test();이렇게 선언해서 test 함수를 실행해보면 어떤 결과가 나올까??결과는 1로 a의 값이 잘 나온다 😱아까 말했듯이 전역 스코프에 선언된 변수는 어디서든지 접근(참조)가 가능해서 값이 잘 나오는 것이다.하지만 아까처럼 함수 내부에 선언된 변수는 지역 변수로 전역에서는 참조가 되지 않는 것이였다.그럼 함수 내부에 또 다른 함수를 선언하고 그 안에 변수를 선언한 것은 어떻게 될까??예제 코드로 알아보자예제 코드 👇var a = 1;function test(){ var b = 1; test2(); function test2(){ console.log(b); // result : 1 }}test();결과와 같이 변수 b의 값인 1이 결과로 잘 나온다.즉 지역 변수는 자신의 지역 스코프 또는 하위 지역 스코프에서 접근(참조)가 가능하다는 것이다 !!!!!!그래서 맨 처음 예제 코드에서 변수 d와 e는 자신의 스코프의 상위 스코프인 전역에서는 접근(참조)가 되지 않아 ReferenceError가 결과로 나왔던 것이다.자바스크립트는 어떻게 이렇게 접근(참조)가 가능한 것일까????그건 자바스크립트 엔진이 스코프체인 이라는 것을 통해 참조할 변수를 검색했기 때문이다.(ㄱ..그만 🤮) 스코프 체인그럼 스코프 체인이라는게 뭘까…위 예제 코드를 보면 함수안에 함수가 있는 걸 볼 수가 있다.이것을 중첩 함수 라고 하는데 정확하게는 test2 함수가 중첩 함수이고, 중첩 함수를 포함하는 함수인 test 함수가 외부 함수 라고 한다.이 말은 스코프가 함수의 중첩에 의해 계층적 구조를 갖는 다는 의미이다.다시 한번 예제 코드로 봐보자.예제 코드 👇var a = 1;function test(){ var b = 1; test2(); function test2(){ console.log(b); // result : 1 var c = 1; }}test();중첩 함수인 test2에 c라는 변수를 추가해 보았다.그럼 연결은 어떻게 되냐 !? 바로 아래와 같이 된다. (이게 최선,,,,,) 전역 스코프   변수 a 값 : 1 ☝ test 지역 스코프   변수 b 값 : 1 ☝ test2 지역 스코프   변수 c 값 : 1 이것이 아까 말한 계층적 구조를 말하고, 검색 또한 이 순서대로 하는데 참조하려는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하면서 검색을 한다. 이것 때문에 test2에서 상위 스코프인 test의 변수 b를 접근(참조)하려고 해도 ReferenceError가 나오지 않았던 이유이다.test2 지역스코프에서 변수 b 검색 -&gt; 없네?? 상위 스코프인 test의 지역 스코프로 이동 -&gt; 변수 b 발견 -&gt; 출력주의 ❗ 상위 스코프에서 하위스코프로 이동해 검색하지 않는다.(접근, 참조 불가능 !!) 함수 레벨 스코프맨 처음에 var과 let, const의 스코프가 다르게 동작한다고 했는데 지금 한 번 알아보자익숙한 자바에서는 함수 뿐만 아니라 모든 코드 블록에서 지역 스코프를 만든다.이것을 블록 레벨 스코프 라고 한다. 하지만 우리 자바스크립트의 var는 다르다.. 바로 예제 코드로 확인해보자.예제 코드 👇var i = 1;for(var i = 0; i&lt;5; i++){ ...}console.log(i);이렇게 선언하면 다른 언어에서는 결과가 1이 나오지만 var로 선언한 자바스크립트에서는 2가 출력이 된다.왜 그러냐 ?!!?!?!?var로 선언된 변수는 함수 만 지역 스코프로 만든다. 예제 코드에 for문은 함수가 아니기 때문에 전역 변수가 되어 버린 것이다.설명은 for문만 했지만 if, for, while, try/catch 등도 전역 변수로 만든다.즉 함수를 제외한 것들은 다 전역변수로 만든다고 알아두면 될 것 같다.이것을 함수 레벨 스코프 라고 한다. 아까 말한 블록 레벨 스코프 와 다른 개념이다 !이러한 것 때문에 블록 레벨 스코프 를 지원하는 let과 const가 ES6부터 도입 되었다.오늘은 스코프에 대해서 알아봤다,, 뭔가 주절주절 쓴 것 같은데 나중에 내가 봐도 알아볼지 모르겠다 😅😅참조 : 모던 자바스크립트 Deep Dive / MDN" }, { "title": "[알고리즘] 문자열 검색 Naive Pattern Searching Algorithm", "url": "/posts/Naive-Search/", "categories": "Javascript, Algorithm", "tags": "Javascript, Algorithm", "date": "2022-06-18 00:00:00 +0900", "snippet": "이번엔 문자열 검색 알고리즘인 Naive Pattern Searching Algorithm을 공부하려고 한다.이 알고리즘은 단순하게 처음부터 끝까지 문자를 하나하나 비교해가면서 일치하는 것을 찾는 알고리즘이다. 과정 문자열(arr)과 찾고자하는 문자열(val)이 주어진다. arr의 첫 번째 값과 val의 첫 번째 값을 비교한다. 두 값이 일치하면 arr의 두 번째 값과 val의 두 번째 값을 비교한다. 이번에도 두 값이 일치하면 인덱스를 1씩 늘려가며 val의 값이 모두 일치한지 검사를 한다. 모두 일치하면 count 값을 1 증가 시킨다. 만약 일치하지 않으면 arr의 두 번째 값부터 다시 위의 과정을 반복한다. 이 처럼 단순하게 모든 배열의 값들을 하나하나 비교하는 과정이다.위 과정을 자바스크립트 코드로 봐보자 ❗예제 코드 👇function naive(arr, val){ let count = 0; for(let i=0; i&lt;arr.length; i++){ // 문자열을 하나씩 반복한다. for(let j=0; j&lt;val.length; j++){ // 찾고자하는 문자열도 마찬가지로 하나씩 반복한다. if(arr[i+j] !== val[j]){ break; // 서로 비교 했을 때 같지 않으면 바로 다음으로 넘기기 위해 break } if(j === val.length - 1){ // val값과 모두 일치하기 때문에 count 1 증가 count++; } } } return count; // 찾은 문자열의 갯수를 출력}이렇게 문자열 검색은 끝이 났다.위 코드보다 더 잘 짜여진 코드가 있겠지만 차근차근 하나씩 배워 나가보자 ❗❗" }, { "title": "[알고리즘] 이진탐색 Binary Search", "url": "/posts/Binary_Search/", "categories": "Javascript, Algorithm", "tags": "Javascript, Algorithm", "date": "2022-06-18 00:00:00 +0900", "snippet": "이진 탐색 Binary Search 하는 방법에 대해서 알아보자. 이진 탐색 Binary Search이진 탐색이란 정렬되어 있는 배열의 반을 나눠가며 검색을 하는 알고리즘이다.빅오 표기법은 O(log n) 이다. 과정 정렬되어 있는 배열의 처음 부분(left)과 끝 부분(right)을 포인터로 잡는다. 배열의 중간 지점을 찾는다. 중간 지점의 값(mid)과 찾고자 하는 값(val)을 비교한다. mid 값이 더 클 경우 right를 mid 보다 한칸 앞으로 이동한다. 반대의 경우 left를 중간 지점 보다 한칸 뒤로 이동한다. 이동 후의 left와 right의 중간 지점을 다시 mid로 잡는다. 다시 3번 과정부터 반복한다. 위 과정을 자바스크립트 코드로 다시 한번 봐보자 ❗예제 코드 👇// 반복문이 끝나는 조건은 배열의 찾는 값이 있어 반환 되거나 배열의 찾는 값이 없을 때 -1을 반환하는 조건이다.function binary(arr, val){ let left = 0; // 배열의 첫 부분을 가리키는 포인터 let right = arr.length - 1; // 배열의 마지막 부분을 가리키는 포인터 let mid; // 배열의 중간 부분을 가리키는 포인터 while(left &lt;= right){ // 값이 없을 경우 무한반복 되는 것을 막기 위한 조건 mid = Math.floor((left+right)/2); // mid 값을 구하는 과정 if(arr[mid] === val){\t\t\treturn mid; \t// 현재 인덱스가 val과 같으므로 현재 인덱스 값 반환\t\t}else if(arr[mid] &gt; val){\t\t\tright = mid - 1; // mid 값이 더 큰 경우 mid보다 한칸 앞으로 설정\t\t}else{\t\t\tleft = mid + 1; // mid 값이 더 작은 경우 mid 보다 한칸 뒤로 설정\t\t}\t\treturn -1; }}위 예제 코드가 과정 에서 글로 설명한 것을 코드로 나타낸 것이다 ❗❗이진 탐색은 그렇게 어렵지 않았지만 다른 알고리즘들은 더 어렵겠지 ༼ಢ_ಢ༽열심히 해보자,, 💪💪" }, { "title": "[오늘의 배움] 정규표현식", "url": "/posts/regexp/", "categories": "Javascript", "tags": "오늘의배움, Javascript", "date": "2022-06-17 00:00:00 +0900", "snippet": "오늘은 공부해야지 해야지 하다가 계속 미뤘던 정규표현식에 대해서 알아보려고 한다. 😅 정규표현식이란 ?정규표현식 : 문자열에서 특정 문자를 찾기 위한 패턴.보통 회원 가입할 때 아이디, 이메일, 비밀번호 형식 등을 검사할 때 많이 사용한다 !정규표현식은 객체기 때문에 RegExp 생성자 함수를 사용해서 객체를 생성할 수도 있다 !!만약 정규표현식이 없었다면 😱 반복문과 조건문을 통해 하나하나 검사해야 하기 때문에 엄청 힘들 것 같다. 정규표현식 사용법정규표현식은 따옴표는 생략해도 된다 ! 따옴표를 사용하면 따옴표까지도 패턴에 포함해서 검색해버리니 주의 !정규표현식의 표현은 다음과 같다./패턴/플래그 예제로 확인해보자.예제 코드 👇const str = \"Hello World\";// 이 정규표현식은 l을 찾는 표현식이고 플래그 i는 대소문자를 구문하지 않는 것이다 !const reg = /l/i;reg.test(str); //result : true;// 아래와 같이 변수에 넣지 않고 바로 사용도 가능하다./l/i.test(str); // result : true; 정규표현식의 플래그플래그들은 순서 상관없이 /패턴/플래그 에서 플래그 자리에 넣어서 사용하면 된다. 플래그 의미 설명 i Ignore case 대소문자 구별 안함 g Global 받은 문자열 전체를 검색 m Multi line 문자열의 행이 바뀌어도 검색 정규표현식 메서드다음은 정규표현식의 메서드들에 대해서 알아보자. exec 메서드 exec 메서드는 매개변수로 받은 문자열을 정규표현식의 패턴으로 검색하여 결과를 배열로 반환해준다.⭐exec 메서드는 플래그 g를 사용해도 첫 번째 매칭 결과만 반환한다 !예제 코드 👇let str = \"Hello World\";let reg = /ll/;reg.exec(str); // result : ['l', index: 2, input: 'Hello World', groups: undefined] test 메서드 test 메서드는 매개변수로 받은 문자열을 정규표현식의 패턴으로 검색하여 결과를 boolean 값으로 반환해준다.예제 코드 👇let str = \"Hello World\";let reg = /ll/;reg.test(str); // result : true match 메서드 match 메서드는 exec와 비슷한데 플래그 g를 사용하면 모든 매칭결과를 배열로 반환한다는 차이점이 있다.예제 코드 👇let str = \"Hello World\";let reg = /ll/;str.test(reg); // result : ['l', 'l', 'l'] 정규표현식 패턴 사용다음은 정규표현식 패턴을 사용할 때 무엇이 있는지 알아보자. 임의의 문자열 검색 정규표현식의 패턴 중 . 은 임의의 문자 한 개를 의미한다. .을 여러개 쓰면 내용과 상관없이 쓴 갯수만큼 검색한다예제 코드 👇let str = \"Hello World\";let reg = /../g; // 플래그 g를 사용했으므로 전체를 검색str.match(reg); // result : ['He', 'll', 'o ', 'Wo', 'rl'] .을 두 개 썻으니 2개씩 검색된다. 반복 검색 찾고 싶은 패턴 뒤에 {n,m}을 써주면 최소 n번, 최대 m번 반복되는 문자를 검색한다. ,뒤에 띄어쓰기가 안들어가도록 주의 !+는 최소 한번 이상 반복되는 문자열을 검색하는 패턴이다.?는 바로 앞 패턴이 최소 0 번 최대 한번 이상 반복되는 문자열을 검색하는 패턴이다. 즉 있어도 되고 없어도 된다.예제 코드 👇let str = \"Hello World\";let reg = /l{1,2}/g; // l이 최소 1번 최대 2번 반복되는 문자 검색// /l+/g; 이렇게 넣어도 결과는 동일하다.str.match(reg); // result : ['ll', 'l']let reg = /la?/g; // result : ['l', 'l', 'l'] or 검색 이름 그대로 or( ) 검색을 한다 ! /h|e/ig; 이렇게 쓰면 h또는 e를 검색한다. 예제 코드는 건너 뛰겠다. 범위 지정 0~9 그리고 a~z 까지 검색하려고 한다면 정말 힘들 것이다. 하지만 [] 안에 범위를 지정해 간단하게 검색이 가능하다.예제 코드 👇let str = \"Hello World\";let reg = /[a-z]/g; // a~z까지 검색,str.match(reg); // result : ['e', 'l', 'l', 'o', 'o', 'r', 'l', 'd']// 만약 대문자도 검색하고 싶다면 [A-Za-z]로 검색하면 된다.// /[A-Za-z]/g; result :['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']// 숫자도 마찬가지로 [0-9]로 검색하면 된다. 다른 방식으로 검색하기 이번엔 지금까지 검색한 것과 의미는 같지만 사용을 다르게 해서 검색해보는 법을 알아보자. 사용법 설명 \\d 숫자를 의미 === [0-9] \\D 숫자가 아닌 문자를 의미 \\w 알파벳, 숫자, 언더스코어(_)를 의미 \\W 알파벳, 숫자, 언더스코어(_)가 아닌 문자를 의미 ^ [패턴] 안에서는 not을 의미하고 [패턴] 밖에서는 문자의 시작을 의미 $ 문자열의 마지막을 의미 이것으로 정규표현식에 대해 거의 다 알아본 것 같다… (아직 모르는게 많지만 😥)이제 이걸 응용해서 정규표현식을 짜보면 될 것 같다 !!참조 : 모던 자바스크립트 Deep Dive / MDN" }, { "title": "github.io 블로그 시작하기", "url": "/posts/first/", "categories": "Blog", "tags": "Blog", "date": "2022-06-16 00:00:00 +0900", "snippet": "깃허브 블로그 시작 후 첫 포스팅가보자아아아아" } ]
